// Code generated by http://github.com/gojuno/minimock (v3.4.3). DO NOT EDIT.

package mocks

//go:generate minimock -i github.com/sSmok/chat-server/internal/repository.ChatRepositoryI -o chat_repository_i_minimock.go -n ChatRepositoryIMock -p mocks

import (
	"context"
	"sync"
	mm_atomic "sync/atomic"
	mm_time "time"

	"github.com/gojuno/minimock/v3"
	"github.com/sSmok/chat-server/internal/model"
)

// ChatRepositoryIMock implements mm_repository.ChatRepositoryI
type ChatRepositoryIMock struct {
	t          minimock.Tester
	finishOnce sync.Once

	funcAddUsersToChat          func(ctx context.Context, chatID int64, userIDs []int64) (err error)
	funcAddUsersToChatOrigin    string
	inspectFuncAddUsersToChat   func(ctx context.Context, chatID int64, userIDs []int64)
	afterAddUsersToChatCounter  uint64
	beforeAddUsersToChatCounter uint64
	AddUsersToChatMock          mChatRepositoryIMockAddUsersToChat

	funcCreateChat          func(ctx context.Context, info *model.ChatInfo) (i1 int64, err error)
	funcCreateChatOrigin    string
	inspectFuncCreateChat   func(ctx context.Context, info *model.ChatInfo)
	afterCreateChatCounter  uint64
	beforeCreateChatCounter uint64
	CreateChatMock          mChatRepositoryIMockCreateChat

	funcCreateMessage          func(ctx context.Context, info *model.MessageInfo) (err error)
	funcCreateMessageOrigin    string
	inspectFuncCreateMessage   func(ctx context.Context, info *model.MessageInfo)
	afterCreateMessageCounter  uint64
	beforeCreateMessageCounter uint64
	CreateMessageMock          mChatRepositoryIMockCreateMessage

	funcCreateUser          func(ctx context.Context, info *model.UserInfo) (i1 int64, err error)
	funcCreateUserOrigin    string
	inspectFuncCreateUser   func(ctx context.Context, info *model.UserInfo)
	afterCreateUserCounter  uint64
	beforeCreateUserCounter uint64
	CreateUserMock          mChatRepositoryIMockCreateUser

	funcDeleteChat          func(ctx context.Context, id int64) (err error)
	funcDeleteChatOrigin    string
	inspectFuncDeleteChat   func(ctx context.Context, id int64)
	afterDeleteChatCounter  uint64
	beforeDeleteChatCounter uint64
	DeleteChatMock          mChatRepositoryIMockDeleteChat

	funcDeleteUser          func(ctx context.Context, id int64) (err error)
	funcDeleteUserOrigin    string
	inspectFuncDeleteUser   func(ctx context.Context, id int64)
	afterDeleteUserCounter  uint64
	beforeDeleteUserCounter uint64
	DeleteUserMock          mChatRepositoryIMockDeleteUser
}

// NewChatRepositoryIMock returns a mock for mm_repository.ChatRepositoryI
func NewChatRepositoryIMock(t minimock.Tester) *ChatRepositoryIMock {
	m := &ChatRepositoryIMock{t: t}

	if controller, ok := t.(minimock.MockController); ok {
		controller.RegisterMocker(m)
	}

	m.AddUsersToChatMock = mChatRepositoryIMockAddUsersToChat{mock: m}
	m.AddUsersToChatMock.callArgs = []*ChatRepositoryIMockAddUsersToChatParams{}

	m.CreateChatMock = mChatRepositoryIMockCreateChat{mock: m}
	m.CreateChatMock.callArgs = []*ChatRepositoryIMockCreateChatParams{}

	m.CreateMessageMock = mChatRepositoryIMockCreateMessage{mock: m}
	m.CreateMessageMock.callArgs = []*ChatRepositoryIMockCreateMessageParams{}

	m.CreateUserMock = mChatRepositoryIMockCreateUser{mock: m}
	m.CreateUserMock.callArgs = []*ChatRepositoryIMockCreateUserParams{}

	m.DeleteChatMock = mChatRepositoryIMockDeleteChat{mock: m}
	m.DeleteChatMock.callArgs = []*ChatRepositoryIMockDeleteChatParams{}

	m.DeleteUserMock = mChatRepositoryIMockDeleteUser{mock: m}
	m.DeleteUserMock.callArgs = []*ChatRepositoryIMockDeleteUserParams{}

	t.Cleanup(m.MinimockFinish)

	return m
}

type mChatRepositoryIMockAddUsersToChat struct {
	optional           bool
	mock               *ChatRepositoryIMock
	defaultExpectation *ChatRepositoryIMockAddUsersToChatExpectation
	expectations       []*ChatRepositoryIMockAddUsersToChatExpectation

	callArgs []*ChatRepositoryIMockAddUsersToChatParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// ChatRepositoryIMockAddUsersToChatExpectation specifies expectation struct of the ChatRepositoryI.AddUsersToChat
type ChatRepositoryIMockAddUsersToChatExpectation struct {
	mock               *ChatRepositoryIMock
	params             *ChatRepositoryIMockAddUsersToChatParams
	paramPtrs          *ChatRepositoryIMockAddUsersToChatParamPtrs
	expectationOrigins ChatRepositoryIMockAddUsersToChatExpectationOrigins
	results            *ChatRepositoryIMockAddUsersToChatResults
	returnOrigin       string
	Counter            uint64
}

// ChatRepositoryIMockAddUsersToChatParams contains parameters of the ChatRepositoryI.AddUsersToChat
type ChatRepositoryIMockAddUsersToChatParams struct {
	ctx     context.Context
	chatID  int64
	userIDs []int64
}

// ChatRepositoryIMockAddUsersToChatParamPtrs contains pointers to parameters of the ChatRepositoryI.AddUsersToChat
type ChatRepositoryIMockAddUsersToChatParamPtrs struct {
	ctx     *context.Context
	chatID  *int64
	userIDs *[]int64
}

// ChatRepositoryIMockAddUsersToChatResults contains results of the ChatRepositoryI.AddUsersToChat
type ChatRepositoryIMockAddUsersToChatResults struct {
	err error
}

// ChatRepositoryIMockAddUsersToChatOrigins contains origins of expectations of the ChatRepositoryI.AddUsersToChat
type ChatRepositoryIMockAddUsersToChatExpectationOrigins struct {
	origin        string
	originCtx     string
	originChatID  string
	originUserIDs string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmAddUsersToChat *mChatRepositoryIMockAddUsersToChat) Optional() *mChatRepositoryIMockAddUsersToChat {
	mmAddUsersToChat.optional = true
	return mmAddUsersToChat
}

// Expect sets up expected params for ChatRepositoryI.AddUsersToChat
func (mmAddUsersToChat *mChatRepositoryIMockAddUsersToChat) Expect(ctx context.Context, chatID int64, userIDs []int64) *mChatRepositoryIMockAddUsersToChat {
	if mmAddUsersToChat.mock.funcAddUsersToChat != nil {
		mmAddUsersToChat.mock.t.Fatalf("ChatRepositoryIMock.AddUsersToChat mock is already set by Set")
	}

	if mmAddUsersToChat.defaultExpectation == nil {
		mmAddUsersToChat.defaultExpectation = &ChatRepositoryIMockAddUsersToChatExpectation{}
	}

	if mmAddUsersToChat.defaultExpectation.paramPtrs != nil {
		mmAddUsersToChat.mock.t.Fatalf("ChatRepositoryIMock.AddUsersToChat mock is already set by ExpectParams functions")
	}

	mmAddUsersToChat.defaultExpectation.params = &ChatRepositoryIMockAddUsersToChatParams{ctx, chatID, userIDs}
	mmAddUsersToChat.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmAddUsersToChat.expectations {
		if minimock.Equal(e.params, mmAddUsersToChat.defaultExpectation.params) {
			mmAddUsersToChat.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmAddUsersToChat.defaultExpectation.params)
		}
	}

	return mmAddUsersToChat
}

// ExpectCtxParam1 sets up expected param ctx for ChatRepositoryI.AddUsersToChat
func (mmAddUsersToChat *mChatRepositoryIMockAddUsersToChat) ExpectCtxParam1(ctx context.Context) *mChatRepositoryIMockAddUsersToChat {
	if mmAddUsersToChat.mock.funcAddUsersToChat != nil {
		mmAddUsersToChat.mock.t.Fatalf("ChatRepositoryIMock.AddUsersToChat mock is already set by Set")
	}

	if mmAddUsersToChat.defaultExpectation == nil {
		mmAddUsersToChat.defaultExpectation = &ChatRepositoryIMockAddUsersToChatExpectation{}
	}

	if mmAddUsersToChat.defaultExpectation.params != nil {
		mmAddUsersToChat.mock.t.Fatalf("ChatRepositoryIMock.AddUsersToChat mock is already set by Expect")
	}

	if mmAddUsersToChat.defaultExpectation.paramPtrs == nil {
		mmAddUsersToChat.defaultExpectation.paramPtrs = &ChatRepositoryIMockAddUsersToChatParamPtrs{}
	}
	mmAddUsersToChat.defaultExpectation.paramPtrs.ctx = &ctx
	mmAddUsersToChat.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmAddUsersToChat
}

// ExpectChatIDParam2 sets up expected param chatID for ChatRepositoryI.AddUsersToChat
func (mmAddUsersToChat *mChatRepositoryIMockAddUsersToChat) ExpectChatIDParam2(chatID int64) *mChatRepositoryIMockAddUsersToChat {
	if mmAddUsersToChat.mock.funcAddUsersToChat != nil {
		mmAddUsersToChat.mock.t.Fatalf("ChatRepositoryIMock.AddUsersToChat mock is already set by Set")
	}

	if mmAddUsersToChat.defaultExpectation == nil {
		mmAddUsersToChat.defaultExpectation = &ChatRepositoryIMockAddUsersToChatExpectation{}
	}

	if mmAddUsersToChat.defaultExpectation.params != nil {
		mmAddUsersToChat.mock.t.Fatalf("ChatRepositoryIMock.AddUsersToChat mock is already set by Expect")
	}

	if mmAddUsersToChat.defaultExpectation.paramPtrs == nil {
		mmAddUsersToChat.defaultExpectation.paramPtrs = &ChatRepositoryIMockAddUsersToChatParamPtrs{}
	}
	mmAddUsersToChat.defaultExpectation.paramPtrs.chatID = &chatID
	mmAddUsersToChat.defaultExpectation.expectationOrigins.originChatID = minimock.CallerInfo(1)

	return mmAddUsersToChat
}

// ExpectUserIDsParam3 sets up expected param userIDs for ChatRepositoryI.AddUsersToChat
func (mmAddUsersToChat *mChatRepositoryIMockAddUsersToChat) ExpectUserIDsParam3(userIDs []int64) *mChatRepositoryIMockAddUsersToChat {
	if mmAddUsersToChat.mock.funcAddUsersToChat != nil {
		mmAddUsersToChat.mock.t.Fatalf("ChatRepositoryIMock.AddUsersToChat mock is already set by Set")
	}

	if mmAddUsersToChat.defaultExpectation == nil {
		mmAddUsersToChat.defaultExpectation = &ChatRepositoryIMockAddUsersToChatExpectation{}
	}

	if mmAddUsersToChat.defaultExpectation.params != nil {
		mmAddUsersToChat.mock.t.Fatalf("ChatRepositoryIMock.AddUsersToChat mock is already set by Expect")
	}

	if mmAddUsersToChat.defaultExpectation.paramPtrs == nil {
		mmAddUsersToChat.defaultExpectation.paramPtrs = &ChatRepositoryIMockAddUsersToChatParamPtrs{}
	}
	mmAddUsersToChat.defaultExpectation.paramPtrs.userIDs = &userIDs
	mmAddUsersToChat.defaultExpectation.expectationOrigins.originUserIDs = minimock.CallerInfo(1)

	return mmAddUsersToChat
}

// Inspect accepts an inspector function that has same arguments as the ChatRepositoryI.AddUsersToChat
func (mmAddUsersToChat *mChatRepositoryIMockAddUsersToChat) Inspect(f func(ctx context.Context, chatID int64, userIDs []int64)) *mChatRepositoryIMockAddUsersToChat {
	if mmAddUsersToChat.mock.inspectFuncAddUsersToChat != nil {
		mmAddUsersToChat.mock.t.Fatalf("Inspect function is already set for ChatRepositoryIMock.AddUsersToChat")
	}

	mmAddUsersToChat.mock.inspectFuncAddUsersToChat = f

	return mmAddUsersToChat
}

// Return sets up results that will be returned by ChatRepositoryI.AddUsersToChat
func (mmAddUsersToChat *mChatRepositoryIMockAddUsersToChat) Return(err error) *ChatRepositoryIMock {
	if mmAddUsersToChat.mock.funcAddUsersToChat != nil {
		mmAddUsersToChat.mock.t.Fatalf("ChatRepositoryIMock.AddUsersToChat mock is already set by Set")
	}

	if mmAddUsersToChat.defaultExpectation == nil {
		mmAddUsersToChat.defaultExpectation = &ChatRepositoryIMockAddUsersToChatExpectation{mock: mmAddUsersToChat.mock}
	}
	mmAddUsersToChat.defaultExpectation.results = &ChatRepositoryIMockAddUsersToChatResults{err}
	mmAddUsersToChat.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmAddUsersToChat.mock
}

// Set uses given function f to mock the ChatRepositoryI.AddUsersToChat method
func (mmAddUsersToChat *mChatRepositoryIMockAddUsersToChat) Set(f func(ctx context.Context, chatID int64, userIDs []int64) (err error)) *ChatRepositoryIMock {
	if mmAddUsersToChat.defaultExpectation != nil {
		mmAddUsersToChat.mock.t.Fatalf("Default expectation is already set for the ChatRepositoryI.AddUsersToChat method")
	}

	if len(mmAddUsersToChat.expectations) > 0 {
		mmAddUsersToChat.mock.t.Fatalf("Some expectations are already set for the ChatRepositoryI.AddUsersToChat method")
	}

	mmAddUsersToChat.mock.funcAddUsersToChat = f
	mmAddUsersToChat.mock.funcAddUsersToChatOrigin = minimock.CallerInfo(1)
	return mmAddUsersToChat.mock
}

// When sets expectation for the ChatRepositoryI.AddUsersToChat which will trigger the result defined by the following
// Then helper
func (mmAddUsersToChat *mChatRepositoryIMockAddUsersToChat) When(ctx context.Context, chatID int64, userIDs []int64) *ChatRepositoryIMockAddUsersToChatExpectation {
	if mmAddUsersToChat.mock.funcAddUsersToChat != nil {
		mmAddUsersToChat.mock.t.Fatalf("ChatRepositoryIMock.AddUsersToChat mock is already set by Set")
	}

	expectation := &ChatRepositoryIMockAddUsersToChatExpectation{
		mock:               mmAddUsersToChat.mock,
		params:             &ChatRepositoryIMockAddUsersToChatParams{ctx, chatID, userIDs},
		expectationOrigins: ChatRepositoryIMockAddUsersToChatExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmAddUsersToChat.expectations = append(mmAddUsersToChat.expectations, expectation)
	return expectation
}

// Then sets up ChatRepositoryI.AddUsersToChat return parameters for the expectation previously defined by the When method
func (e *ChatRepositoryIMockAddUsersToChatExpectation) Then(err error) *ChatRepositoryIMock {
	e.results = &ChatRepositoryIMockAddUsersToChatResults{err}
	return e.mock
}

// Times sets number of times ChatRepositoryI.AddUsersToChat should be invoked
func (mmAddUsersToChat *mChatRepositoryIMockAddUsersToChat) Times(n uint64) *mChatRepositoryIMockAddUsersToChat {
	if n == 0 {
		mmAddUsersToChat.mock.t.Fatalf("Times of ChatRepositoryIMock.AddUsersToChat mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmAddUsersToChat.expectedInvocations, n)
	mmAddUsersToChat.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmAddUsersToChat
}

func (mmAddUsersToChat *mChatRepositoryIMockAddUsersToChat) invocationsDone() bool {
	if len(mmAddUsersToChat.expectations) == 0 && mmAddUsersToChat.defaultExpectation == nil && mmAddUsersToChat.mock.funcAddUsersToChat == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmAddUsersToChat.mock.afterAddUsersToChatCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmAddUsersToChat.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// AddUsersToChat implements mm_repository.ChatRepositoryI
func (mmAddUsersToChat *ChatRepositoryIMock) AddUsersToChat(ctx context.Context, chatID int64, userIDs []int64) (err error) {
	mm_atomic.AddUint64(&mmAddUsersToChat.beforeAddUsersToChatCounter, 1)
	defer mm_atomic.AddUint64(&mmAddUsersToChat.afterAddUsersToChatCounter, 1)

	mmAddUsersToChat.t.Helper()

	if mmAddUsersToChat.inspectFuncAddUsersToChat != nil {
		mmAddUsersToChat.inspectFuncAddUsersToChat(ctx, chatID, userIDs)
	}

	mm_params := ChatRepositoryIMockAddUsersToChatParams{ctx, chatID, userIDs}

	// Record call args
	mmAddUsersToChat.AddUsersToChatMock.mutex.Lock()
	mmAddUsersToChat.AddUsersToChatMock.callArgs = append(mmAddUsersToChat.AddUsersToChatMock.callArgs, &mm_params)
	mmAddUsersToChat.AddUsersToChatMock.mutex.Unlock()

	for _, e := range mmAddUsersToChat.AddUsersToChatMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmAddUsersToChat.AddUsersToChatMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmAddUsersToChat.AddUsersToChatMock.defaultExpectation.Counter, 1)
		mm_want := mmAddUsersToChat.AddUsersToChatMock.defaultExpectation.params
		mm_want_ptrs := mmAddUsersToChat.AddUsersToChatMock.defaultExpectation.paramPtrs

		mm_got := ChatRepositoryIMockAddUsersToChatParams{ctx, chatID, userIDs}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmAddUsersToChat.t.Errorf("ChatRepositoryIMock.AddUsersToChat got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmAddUsersToChat.AddUsersToChatMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.chatID != nil && !minimock.Equal(*mm_want_ptrs.chatID, mm_got.chatID) {
				mmAddUsersToChat.t.Errorf("ChatRepositoryIMock.AddUsersToChat got unexpected parameter chatID, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmAddUsersToChat.AddUsersToChatMock.defaultExpectation.expectationOrigins.originChatID, *mm_want_ptrs.chatID, mm_got.chatID, minimock.Diff(*mm_want_ptrs.chatID, mm_got.chatID))
			}

			if mm_want_ptrs.userIDs != nil && !minimock.Equal(*mm_want_ptrs.userIDs, mm_got.userIDs) {
				mmAddUsersToChat.t.Errorf("ChatRepositoryIMock.AddUsersToChat got unexpected parameter userIDs, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmAddUsersToChat.AddUsersToChatMock.defaultExpectation.expectationOrigins.originUserIDs, *mm_want_ptrs.userIDs, mm_got.userIDs, minimock.Diff(*mm_want_ptrs.userIDs, mm_got.userIDs))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmAddUsersToChat.t.Errorf("ChatRepositoryIMock.AddUsersToChat got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmAddUsersToChat.AddUsersToChatMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmAddUsersToChat.AddUsersToChatMock.defaultExpectation.results
		if mm_results == nil {
			mmAddUsersToChat.t.Fatal("No results are set for the ChatRepositoryIMock.AddUsersToChat")
		}
		return (*mm_results).err
	}
	if mmAddUsersToChat.funcAddUsersToChat != nil {
		return mmAddUsersToChat.funcAddUsersToChat(ctx, chatID, userIDs)
	}
	mmAddUsersToChat.t.Fatalf("Unexpected call to ChatRepositoryIMock.AddUsersToChat. %v %v %v", ctx, chatID, userIDs)
	return
}

// AddUsersToChatAfterCounter returns a count of finished ChatRepositoryIMock.AddUsersToChat invocations
func (mmAddUsersToChat *ChatRepositoryIMock) AddUsersToChatAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmAddUsersToChat.afterAddUsersToChatCounter)
}

// AddUsersToChatBeforeCounter returns a count of ChatRepositoryIMock.AddUsersToChat invocations
func (mmAddUsersToChat *ChatRepositoryIMock) AddUsersToChatBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmAddUsersToChat.beforeAddUsersToChatCounter)
}

// Calls returns a list of arguments used in each call to ChatRepositoryIMock.AddUsersToChat.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmAddUsersToChat *mChatRepositoryIMockAddUsersToChat) Calls() []*ChatRepositoryIMockAddUsersToChatParams {
	mmAddUsersToChat.mutex.RLock()

	argCopy := make([]*ChatRepositoryIMockAddUsersToChatParams, len(mmAddUsersToChat.callArgs))
	copy(argCopy, mmAddUsersToChat.callArgs)

	mmAddUsersToChat.mutex.RUnlock()

	return argCopy
}

// MinimockAddUsersToChatDone returns true if the count of the AddUsersToChat invocations corresponds
// the number of defined expectations
func (m *ChatRepositoryIMock) MinimockAddUsersToChatDone() bool {
	if m.AddUsersToChatMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.AddUsersToChatMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.AddUsersToChatMock.invocationsDone()
}

// MinimockAddUsersToChatInspect logs each unmet expectation
func (m *ChatRepositoryIMock) MinimockAddUsersToChatInspect() {
	for _, e := range m.AddUsersToChatMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to ChatRepositoryIMock.AddUsersToChat at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterAddUsersToChatCounter := mm_atomic.LoadUint64(&m.afterAddUsersToChatCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.AddUsersToChatMock.defaultExpectation != nil && afterAddUsersToChatCounter < 1 {
		if m.AddUsersToChatMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to ChatRepositoryIMock.AddUsersToChat at\n%s", m.AddUsersToChatMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to ChatRepositoryIMock.AddUsersToChat at\n%s with params: %#v", m.AddUsersToChatMock.defaultExpectation.expectationOrigins.origin, *m.AddUsersToChatMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcAddUsersToChat != nil && afterAddUsersToChatCounter < 1 {
		m.t.Errorf("Expected call to ChatRepositoryIMock.AddUsersToChat at\n%s", m.funcAddUsersToChatOrigin)
	}

	if !m.AddUsersToChatMock.invocationsDone() && afterAddUsersToChatCounter > 0 {
		m.t.Errorf("Expected %d calls to ChatRepositoryIMock.AddUsersToChat at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.AddUsersToChatMock.expectedInvocations), m.AddUsersToChatMock.expectedInvocationsOrigin, afterAddUsersToChatCounter)
	}
}

type mChatRepositoryIMockCreateChat struct {
	optional           bool
	mock               *ChatRepositoryIMock
	defaultExpectation *ChatRepositoryIMockCreateChatExpectation
	expectations       []*ChatRepositoryIMockCreateChatExpectation

	callArgs []*ChatRepositoryIMockCreateChatParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// ChatRepositoryIMockCreateChatExpectation specifies expectation struct of the ChatRepositoryI.CreateChat
type ChatRepositoryIMockCreateChatExpectation struct {
	mock               *ChatRepositoryIMock
	params             *ChatRepositoryIMockCreateChatParams
	paramPtrs          *ChatRepositoryIMockCreateChatParamPtrs
	expectationOrigins ChatRepositoryIMockCreateChatExpectationOrigins
	results            *ChatRepositoryIMockCreateChatResults
	returnOrigin       string
	Counter            uint64
}

// ChatRepositoryIMockCreateChatParams contains parameters of the ChatRepositoryI.CreateChat
type ChatRepositoryIMockCreateChatParams struct {
	ctx  context.Context
	info *model.ChatInfo
}

// ChatRepositoryIMockCreateChatParamPtrs contains pointers to parameters of the ChatRepositoryI.CreateChat
type ChatRepositoryIMockCreateChatParamPtrs struct {
	ctx  *context.Context
	info **model.ChatInfo
}

// ChatRepositoryIMockCreateChatResults contains results of the ChatRepositoryI.CreateChat
type ChatRepositoryIMockCreateChatResults struct {
	i1  int64
	err error
}

// ChatRepositoryIMockCreateChatOrigins contains origins of expectations of the ChatRepositoryI.CreateChat
type ChatRepositoryIMockCreateChatExpectationOrigins struct {
	origin     string
	originCtx  string
	originInfo string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmCreateChat *mChatRepositoryIMockCreateChat) Optional() *mChatRepositoryIMockCreateChat {
	mmCreateChat.optional = true
	return mmCreateChat
}

// Expect sets up expected params for ChatRepositoryI.CreateChat
func (mmCreateChat *mChatRepositoryIMockCreateChat) Expect(ctx context.Context, info *model.ChatInfo) *mChatRepositoryIMockCreateChat {
	if mmCreateChat.mock.funcCreateChat != nil {
		mmCreateChat.mock.t.Fatalf("ChatRepositoryIMock.CreateChat mock is already set by Set")
	}

	if mmCreateChat.defaultExpectation == nil {
		mmCreateChat.defaultExpectation = &ChatRepositoryIMockCreateChatExpectation{}
	}

	if mmCreateChat.defaultExpectation.paramPtrs != nil {
		mmCreateChat.mock.t.Fatalf("ChatRepositoryIMock.CreateChat mock is already set by ExpectParams functions")
	}

	mmCreateChat.defaultExpectation.params = &ChatRepositoryIMockCreateChatParams{ctx, info}
	mmCreateChat.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmCreateChat.expectations {
		if minimock.Equal(e.params, mmCreateChat.defaultExpectation.params) {
			mmCreateChat.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmCreateChat.defaultExpectation.params)
		}
	}

	return mmCreateChat
}

// ExpectCtxParam1 sets up expected param ctx for ChatRepositoryI.CreateChat
func (mmCreateChat *mChatRepositoryIMockCreateChat) ExpectCtxParam1(ctx context.Context) *mChatRepositoryIMockCreateChat {
	if mmCreateChat.mock.funcCreateChat != nil {
		mmCreateChat.mock.t.Fatalf("ChatRepositoryIMock.CreateChat mock is already set by Set")
	}

	if mmCreateChat.defaultExpectation == nil {
		mmCreateChat.defaultExpectation = &ChatRepositoryIMockCreateChatExpectation{}
	}

	if mmCreateChat.defaultExpectation.params != nil {
		mmCreateChat.mock.t.Fatalf("ChatRepositoryIMock.CreateChat mock is already set by Expect")
	}

	if mmCreateChat.defaultExpectation.paramPtrs == nil {
		mmCreateChat.defaultExpectation.paramPtrs = &ChatRepositoryIMockCreateChatParamPtrs{}
	}
	mmCreateChat.defaultExpectation.paramPtrs.ctx = &ctx
	mmCreateChat.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmCreateChat
}

// ExpectInfoParam2 sets up expected param info for ChatRepositoryI.CreateChat
func (mmCreateChat *mChatRepositoryIMockCreateChat) ExpectInfoParam2(info *model.ChatInfo) *mChatRepositoryIMockCreateChat {
	if mmCreateChat.mock.funcCreateChat != nil {
		mmCreateChat.mock.t.Fatalf("ChatRepositoryIMock.CreateChat mock is already set by Set")
	}

	if mmCreateChat.defaultExpectation == nil {
		mmCreateChat.defaultExpectation = &ChatRepositoryIMockCreateChatExpectation{}
	}

	if mmCreateChat.defaultExpectation.params != nil {
		mmCreateChat.mock.t.Fatalf("ChatRepositoryIMock.CreateChat mock is already set by Expect")
	}

	if mmCreateChat.defaultExpectation.paramPtrs == nil {
		mmCreateChat.defaultExpectation.paramPtrs = &ChatRepositoryIMockCreateChatParamPtrs{}
	}
	mmCreateChat.defaultExpectation.paramPtrs.info = &info
	mmCreateChat.defaultExpectation.expectationOrigins.originInfo = minimock.CallerInfo(1)

	return mmCreateChat
}

// Inspect accepts an inspector function that has same arguments as the ChatRepositoryI.CreateChat
func (mmCreateChat *mChatRepositoryIMockCreateChat) Inspect(f func(ctx context.Context, info *model.ChatInfo)) *mChatRepositoryIMockCreateChat {
	if mmCreateChat.mock.inspectFuncCreateChat != nil {
		mmCreateChat.mock.t.Fatalf("Inspect function is already set for ChatRepositoryIMock.CreateChat")
	}

	mmCreateChat.mock.inspectFuncCreateChat = f

	return mmCreateChat
}

// Return sets up results that will be returned by ChatRepositoryI.CreateChat
func (mmCreateChat *mChatRepositoryIMockCreateChat) Return(i1 int64, err error) *ChatRepositoryIMock {
	if mmCreateChat.mock.funcCreateChat != nil {
		mmCreateChat.mock.t.Fatalf("ChatRepositoryIMock.CreateChat mock is already set by Set")
	}

	if mmCreateChat.defaultExpectation == nil {
		mmCreateChat.defaultExpectation = &ChatRepositoryIMockCreateChatExpectation{mock: mmCreateChat.mock}
	}
	mmCreateChat.defaultExpectation.results = &ChatRepositoryIMockCreateChatResults{i1, err}
	mmCreateChat.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmCreateChat.mock
}

// Set uses given function f to mock the ChatRepositoryI.CreateChat method
func (mmCreateChat *mChatRepositoryIMockCreateChat) Set(f func(ctx context.Context, info *model.ChatInfo) (i1 int64, err error)) *ChatRepositoryIMock {
	if mmCreateChat.defaultExpectation != nil {
		mmCreateChat.mock.t.Fatalf("Default expectation is already set for the ChatRepositoryI.CreateChat method")
	}

	if len(mmCreateChat.expectations) > 0 {
		mmCreateChat.mock.t.Fatalf("Some expectations are already set for the ChatRepositoryI.CreateChat method")
	}

	mmCreateChat.mock.funcCreateChat = f
	mmCreateChat.mock.funcCreateChatOrigin = minimock.CallerInfo(1)
	return mmCreateChat.mock
}

// When sets expectation for the ChatRepositoryI.CreateChat which will trigger the result defined by the following
// Then helper
func (mmCreateChat *mChatRepositoryIMockCreateChat) When(ctx context.Context, info *model.ChatInfo) *ChatRepositoryIMockCreateChatExpectation {
	if mmCreateChat.mock.funcCreateChat != nil {
		mmCreateChat.mock.t.Fatalf("ChatRepositoryIMock.CreateChat mock is already set by Set")
	}

	expectation := &ChatRepositoryIMockCreateChatExpectation{
		mock:               mmCreateChat.mock,
		params:             &ChatRepositoryIMockCreateChatParams{ctx, info},
		expectationOrigins: ChatRepositoryIMockCreateChatExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmCreateChat.expectations = append(mmCreateChat.expectations, expectation)
	return expectation
}

// Then sets up ChatRepositoryI.CreateChat return parameters for the expectation previously defined by the When method
func (e *ChatRepositoryIMockCreateChatExpectation) Then(i1 int64, err error) *ChatRepositoryIMock {
	e.results = &ChatRepositoryIMockCreateChatResults{i1, err}
	return e.mock
}

// Times sets number of times ChatRepositoryI.CreateChat should be invoked
func (mmCreateChat *mChatRepositoryIMockCreateChat) Times(n uint64) *mChatRepositoryIMockCreateChat {
	if n == 0 {
		mmCreateChat.mock.t.Fatalf("Times of ChatRepositoryIMock.CreateChat mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmCreateChat.expectedInvocations, n)
	mmCreateChat.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmCreateChat
}

func (mmCreateChat *mChatRepositoryIMockCreateChat) invocationsDone() bool {
	if len(mmCreateChat.expectations) == 0 && mmCreateChat.defaultExpectation == nil && mmCreateChat.mock.funcCreateChat == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmCreateChat.mock.afterCreateChatCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmCreateChat.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// CreateChat implements mm_repository.ChatRepositoryI
func (mmCreateChat *ChatRepositoryIMock) CreateChat(ctx context.Context, info *model.ChatInfo) (i1 int64, err error) {
	mm_atomic.AddUint64(&mmCreateChat.beforeCreateChatCounter, 1)
	defer mm_atomic.AddUint64(&mmCreateChat.afterCreateChatCounter, 1)

	mmCreateChat.t.Helper()

	if mmCreateChat.inspectFuncCreateChat != nil {
		mmCreateChat.inspectFuncCreateChat(ctx, info)
	}

	mm_params := ChatRepositoryIMockCreateChatParams{ctx, info}

	// Record call args
	mmCreateChat.CreateChatMock.mutex.Lock()
	mmCreateChat.CreateChatMock.callArgs = append(mmCreateChat.CreateChatMock.callArgs, &mm_params)
	mmCreateChat.CreateChatMock.mutex.Unlock()

	for _, e := range mmCreateChat.CreateChatMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.i1, e.results.err
		}
	}

	if mmCreateChat.CreateChatMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmCreateChat.CreateChatMock.defaultExpectation.Counter, 1)
		mm_want := mmCreateChat.CreateChatMock.defaultExpectation.params
		mm_want_ptrs := mmCreateChat.CreateChatMock.defaultExpectation.paramPtrs

		mm_got := ChatRepositoryIMockCreateChatParams{ctx, info}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmCreateChat.t.Errorf("ChatRepositoryIMock.CreateChat got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmCreateChat.CreateChatMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.info != nil && !minimock.Equal(*mm_want_ptrs.info, mm_got.info) {
				mmCreateChat.t.Errorf("ChatRepositoryIMock.CreateChat got unexpected parameter info, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmCreateChat.CreateChatMock.defaultExpectation.expectationOrigins.originInfo, *mm_want_ptrs.info, mm_got.info, minimock.Diff(*mm_want_ptrs.info, mm_got.info))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmCreateChat.t.Errorf("ChatRepositoryIMock.CreateChat got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmCreateChat.CreateChatMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmCreateChat.CreateChatMock.defaultExpectation.results
		if mm_results == nil {
			mmCreateChat.t.Fatal("No results are set for the ChatRepositoryIMock.CreateChat")
		}
		return (*mm_results).i1, (*mm_results).err
	}
	if mmCreateChat.funcCreateChat != nil {
		return mmCreateChat.funcCreateChat(ctx, info)
	}
	mmCreateChat.t.Fatalf("Unexpected call to ChatRepositoryIMock.CreateChat. %v %v", ctx, info)
	return
}

// CreateChatAfterCounter returns a count of finished ChatRepositoryIMock.CreateChat invocations
func (mmCreateChat *ChatRepositoryIMock) CreateChatAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmCreateChat.afterCreateChatCounter)
}

// CreateChatBeforeCounter returns a count of ChatRepositoryIMock.CreateChat invocations
func (mmCreateChat *ChatRepositoryIMock) CreateChatBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmCreateChat.beforeCreateChatCounter)
}

// Calls returns a list of arguments used in each call to ChatRepositoryIMock.CreateChat.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmCreateChat *mChatRepositoryIMockCreateChat) Calls() []*ChatRepositoryIMockCreateChatParams {
	mmCreateChat.mutex.RLock()

	argCopy := make([]*ChatRepositoryIMockCreateChatParams, len(mmCreateChat.callArgs))
	copy(argCopy, mmCreateChat.callArgs)

	mmCreateChat.mutex.RUnlock()

	return argCopy
}

// MinimockCreateChatDone returns true if the count of the CreateChat invocations corresponds
// the number of defined expectations
func (m *ChatRepositoryIMock) MinimockCreateChatDone() bool {
	if m.CreateChatMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.CreateChatMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.CreateChatMock.invocationsDone()
}

// MinimockCreateChatInspect logs each unmet expectation
func (m *ChatRepositoryIMock) MinimockCreateChatInspect() {
	for _, e := range m.CreateChatMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to ChatRepositoryIMock.CreateChat at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterCreateChatCounter := mm_atomic.LoadUint64(&m.afterCreateChatCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.CreateChatMock.defaultExpectation != nil && afterCreateChatCounter < 1 {
		if m.CreateChatMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to ChatRepositoryIMock.CreateChat at\n%s", m.CreateChatMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to ChatRepositoryIMock.CreateChat at\n%s with params: %#v", m.CreateChatMock.defaultExpectation.expectationOrigins.origin, *m.CreateChatMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcCreateChat != nil && afterCreateChatCounter < 1 {
		m.t.Errorf("Expected call to ChatRepositoryIMock.CreateChat at\n%s", m.funcCreateChatOrigin)
	}

	if !m.CreateChatMock.invocationsDone() && afterCreateChatCounter > 0 {
		m.t.Errorf("Expected %d calls to ChatRepositoryIMock.CreateChat at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.CreateChatMock.expectedInvocations), m.CreateChatMock.expectedInvocationsOrigin, afterCreateChatCounter)
	}
}

type mChatRepositoryIMockCreateMessage struct {
	optional           bool
	mock               *ChatRepositoryIMock
	defaultExpectation *ChatRepositoryIMockCreateMessageExpectation
	expectations       []*ChatRepositoryIMockCreateMessageExpectation

	callArgs []*ChatRepositoryIMockCreateMessageParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// ChatRepositoryIMockCreateMessageExpectation specifies expectation struct of the ChatRepositoryI.CreateMessage
type ChatRepositoryIMockCreateMessageExpectation struct {
	mock               *ChatRepositoryIMock
	params             *ChatRepositoryIMockCreateMessageParams
	paramPtrs          *ChatRepositoryIMockCreateMessageParamPtrs
	expectationOrigins ChatRepositoryIMockCreateMessageExpectationOrigins
	results            *ChatRepositoryIMockCreateMessageResults
	returnOrigin       string
	Counter            uint64
}

// ChatRepositoryIMockCreateMessageParams contains parameters of the ChatRepositoryI.CreateMessage
type ChatRepositoryIMockCreateMessageParams struct {
	ctx  context.Context
	info *model.MessageInfo
}

// ChatRepositoryIMockCreateMessageParamPtrs contains pointers to parameters of the ChatRepositoryI.CreateMessage
type ChatRepositoryIMockCreateMessageParamPtrs struct {
	ctx  *context.Context
	info **model.MessageInfo
}

// ChatRepositoryIMockCreateMessageResults contains results of the ChatRepositoryI.CreateMessage
type ChatRepositoryIMockCreateMessageResults struct {
	err error
}

// ChatRepositoryIMockCreateMessageOrigins contains origins of expectations of the ChatRepositoryI.CreateMessage
type ChatRepositoryIMockCreateMessageExpectationOrigins struct {
	origin     string
	originCtx  string
	originInfo string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmCreateMessage *mChatRepositoryIMockCreateMessage) Optional() *mChatRepositoryIMockCreateMessage {
	mmCreateMessage.optional = true
	return mmCreateMessage
}

// Expect sets up expected params for ChatRepositoryI.CreateMessage
func (mmCreateMessage *mChatRepositoryIMockCreateMessage) Expect(ctx context.Context, info *model.MessageInfo) *mChatRepositoryIMockCreateMessage {
	if mmCreateMessage.mock.funcCreateMessage != nil {
		mmCreateMessage.mock.t.Fatalf("ChatRepositoryIMock.CreateMessage mock is already set by Set")
	}

	if mmCreateMessage.defaultExpectation == nil {
		mmCreateMessage.defaultExpectation = &ChatRepositoryIMockCreateMessageExpectation{}
	}

	if mmCreateMessage.defaultExpectation.paramPtrs != nil {
		mmCreateMessage.mock.t.Fatalf("ChatRepositoryIMock.CreateMessage mock is already set by ExpectParams functions")
	}

	mmCreateMessage.defaultExpectation.params = &ChatRepositoryIMockCreateMessageParams{ctx, info}
	mmCreateMessage.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmCreateMessage.expectations {
		if minimock.Equal(e.params, mmCreateMessage.defaultExpectation.params) {
			mmCreateMessage.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmCreateMessage.defaultExpectation.params)
		}
	}

	return mmCreateMessage
}

// ExpectCtxParam1 sets up expected param ctx for ChatRepositoryI.CreateMessage
func (mmCreateMessage *mChatRepositoryIMockCreateMessage) ExpectCtxParam1(ctx context.Context) *mChatRepositoryIMockCreateMessage {
	if mmCreateMessage.mock.funcCreateMessage != nil {
		mmCreateMessage.mock.t.Fatalf("ChatRepositoryIMock.CreateMessage mock is already set by Set")
	}

	if mmCreateMessage.defaultExpectation == nil {
		mmCreateMessage.defaultExpectation = &ChatRepositoryIMockCreateMessageExpectation{}
	}

	if mmCreateMessage.defaultExpectation.params != nil {
		mmCreateMessage.mock.t.Fatalf("ChatRepositoryIMock.CreateMessage mock is already set by Expect")
	}

	if mmCreateMessage.defaultExpectation.paramPtrs == nil {
		mmCreateMessage.defaultExpectation.paramPtrs = &ChatRepositoryIMockCreateMessageParamPtrs{}
	}
	mmCreateMessage.defaultExpectation.paramPtrs.ctx = &ctx
	mmCreateMessage.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmCreateMessage
}

// ExpectInfoParam2 sets up expected param info for ChatRepositoryI.CreateMessage
func (mmCreateMessage *mChatRepositoryIMockCreateMessage) ExpectInfoParam2(info *model.MessageInfo) *mChatRepositoryIMockCreateMessage {
	if mmCreateMessage.mock.funcCreateMessage != nil {
		mmCreateMessage.mock.t.Fatalf("ChatRepositoryIMock.CreateMessage mock is already set by Set")
	}

	if mmCreateMessage.defaultExpectation == nil {
		mmCreateMessage.defaultExpectation = &ChatRepositoryIMockCreateMessageExpectation{}
	}

	if mmCreateMessage.defaultExpectation.params != nil {
		mmCreateMessage.mock.t.Fatalf("ChatRepositoryIMock.CreateMessage mock is already set by Expect")
	}

	if mmCreateMessage.defaultExpectation.paramPtrs == nil {
		mmCreateMessage.defaultExpectation.paramPtrs = &ChatRepositoryIMockCreateMessageParamPtrs{}
	}
	mmCreateMessage.defaultExpectation.paramPtrs.info = &info
	mmCreateMessage.defaultExpectation.expectationOrigins.originInfo = minimock.CallerInfo(1)

	return mmCreateMessage
}

// Inspect accepts an inspector function that has same arguments as the ChatRepositoryI.CreateMessage
func (mmCreateMessage *mChatRepositoryIMockCreateMessage) Inspect(f func(ctx context.Context, info *model.MessageInfo)) *mChatRepositoryIMockCreateMessage {
	if mmCreateMessage.mock.inspectFuncCreateMessage != nil {
		mmCreateMessage.mock.t.Fatalf("Inspect function is already set for ChatRepositoryIMock.CreateMessage")
	}

	mmCreateMessage.mock.inspectFuncCreateMessage = f

	return mmCreateMessage
}

// Return sets up results that will be returned by ChatRepositoryI.CreateMessage
func (mmCreateMessage *mChatRepositoryIMockCreateMessage) Return(err error) *ChatRepositoryIMock {
	if mmCreateMessage.mock.funcCreateMessage != nil {
		mmCreateMessage.mock.t.Fatalf("ChatRepositoryIMock.CreateMessage mock is already set by Set")
	}

	if mmCreateMessage.defaultExpectation == nil {
		mmCreateMessage.defaultExpectation = &ChatRepositoryIMockCreateMessageExpectation{mock: mmCreateMessage.mock}
	}
	mmCreateMessage.defaultExpectation.results = &ChatRepositoryIMockCreateMessageResults{err}
	mmCreateMessage.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmCreateMessage.mock
}

// Set uses given function f to mock the ChatRepositoryI.CreateMessage method
func (mmCreateMessage *mChatRepositoryIMockCreateMessage) Set(f func(ctx context.Context, info *model.MessageInfo) (err error)) *ChatRepositoryIMock {
	if mmCreateMessage.defaultExpectation != nil {
		mmCreateMessage.mock.t.Fatalf("Default expectation is already set for the ChatRepositoryI.CreateMessage method")
	}

	if len(mmCreateMessage.expectations) > 0 {
		mmCreateMessage.mock.t.Fatalf("Some expectations are already set for the ChatRepositoryI.CreateMessage method")
	}

	mmCreateMessage.mock.funcCreateMessage = f
	mmCreateMessage.mock.funcCreateMessageOrigin = minimock.CallerInfo(1)
	return mmCreateMessage.mock
}

// When sets expectation for the ChatRepositoryI.CreateMessage which will trigger the result defined by the following
// Then helper
func (mmCreateMessage *mChatRepositoryIMockCreateMessage) When(ctx context.Context, info *model.MessageInfo) *ChatRepositoryIMockCreateMessageExpectation {
	if mmCreateMessage.mock.funcCreateMessage != nil {
		mmCreateMessage.mock.t.Fatalf("ChatRepositoryIMock.CreateMessage mock is already set by Set")
	}

	expectation := &ChatRepositoryIMockCreateMessageExpectation{
		mock:               mmCreateMessage.mock,
		params:             &ChatRepositoryIMockCreateMessageParams{ctx, info},
		expectationOrigins: ChatRepositoryIMockCreateMessageExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmCreateMessage.expectations = append(mmCreateMessage.expectations, expectation)
	return expectation
}

// Then sets up ChatRepositoryI.CreateMessage return parameters for the expectation previously defined by the When method
func (e *ChatRepositoryIMockCreateMessageExpectation) Then(err error) *ChatRepositoryIMock {
	e.results = &ChatRepositoryIMockCreateMessageResults{err}
	return e.mock
}

// Times sets number of times ChatRepositoryI.CreateMessage should be invoked
func (mmCreateMessage *mChatRepositoryIMockCreateMessage) Times(n uint64) *mChatRepositoryIMockCreateMessage {
	if n == 0 {
		mmCreateMessage.mock.t.Fatalf("Times of ChatRepositoryIMock.CreateMessage mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmCreateMessage.expectedInvocations, n)
	mmCreateMessage.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmCreateMessage
}

func (mmCreateMessage *mChatRepositoryIMockCreateMessage) invocationsDone() bool {
	if len(mmCreateMessage.expectations) == 0 && mmCreateMessage.defaultExpectation == nil && mmCreateMessage.mock.funcCreateMessage == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmCreateMessage.mock.afterCreateMessageCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmCreateMessage.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// CreateMessage implements mm_repository.ChatRepositoryI
func (mmCreateMessage *ChatRepositoryIMock) CreateMessage(ctx context.Context, info *model.MessageInfo) (err error) {
	mm_atomic.AddUint64(&mmCreateMessage.beforeCreateMessageCounter, 1)
	defer mm_atomic.AddUint64(&mmCreateMessage.afterCreateMessageCounter, 1)

	mmCreateMessage.t.Helper()

	if mmCreateMessage.inspectFuncCreateMessage != nil {
		mmCreateMessage.inspectFuncCreateMessage(ctx, info)
	}

	mm_params := ChatRepositoryIMockCreateMessageParams{ctx, info}

	// Record call args
	mmCreateMessage.CreateMessageMock.mutex.Lock()
	mmCreateMessage.CreateMessageMock.callArgs = append(mmCreateMessage.CreateMessageMock.callArgs, &mm_params)
	mmCreateMessage.CreateMessageMock.mutex.Unlock()

	for _, e := range mmCreateMessage.CreateMessageMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmCreateMessage.CreateMessageMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmCreateMessage.CreateMessageMock.defaultExpectation.Counter, 1)
		mm_want := mmCreateMessage.CreateMessageMock.defaultExpectation.params
		mm_want_ptrs := mmCreateMessage.CreateMessageMock.defaultExpectation.paramPtrs

		mm_got := ChatRepositoryIMockCreateMessageParams{ctx, info}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmCreateMessage.t.Errorf("ChatRepositoryIMock.CreateMessage got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmCreateMessage.CreateMessageMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.info != nil && !minimock.Equal(*mm_want_ptrs.info, mm_got.info) {
				mmCreateMessage.t.Errorf("ChatRepositoryIMock.CreateMessage got unexpected parameter info, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmCreateMessage.CreateMessageMock.defaultExpectation.expectationOrigins.originInfo, *mm_want_ptrs.info, mm_got.info, minimock.Diff(*mm_want_ptrs.info, mm_got.info))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmCreateMessage.t.Errorf("ChatRepositoryIMock.CreateMessage got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmCreateMessage.CreateMessageMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmCreateMessage.CreateMessageMock.defaultExpectation.results
		if mm_results == nil {
			mmCreateMessage.t.Fatal("No results are set for the ChatRepositoryIMock.CreateMessage")
		}
		return (*mm_results).err
	}
	if mmCreateMessage.funcCreateMessage != nil {
		return mmCreateMessage.funcCreateMessage(ctx, info)
	}
	mmCreateMessage.t.Fatalf("Unexpected call to ChatRepositoryIMock.CreateMessage. %v %v", ctx, info)
	return
}

// CreateMessageAfterCounter returns a count of finished ChatRepositoryIMock.CreateMessage invocations
func (mmCreateMessage *ChatRepositoryIMock) CreateMessageAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmCreateMessage.afterCreateMessageCounter)
}

// CreateMessageBeforeCounter returns a count of ChatRepositoryIMock.CreateMessage invocations
func (mmCreateMessage *ChatRepositoryIMock) CreateMessageBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmCreateMessage.beforeCreateMessageCounter)
}

// Calls returns a list of arguments used in each call to ChatRepositoryIMock.CreateMessage.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmCreateMessage *mChatRepositoryIMockCreateMessage) Calls() []*ChatRepositoryIMockCreateMessageParams {
	mmCreateMessage.mutex.RLock()

	argCopy := make([]*ChatRepositoryIMockCreateMessageParams, len(mmCreateMessage.callArgs))
	copy(argCopy, mmCreateMessage.callArgs)

	mmCreateMessage.mutex.RUnlock()

	return argCopy
}

// MinimockCreateMessageDone returns true if the count of the CreateMessage invocations corresponds
// the number of defined expectations
func (m *ChatRepositoryIMock) MinimockCreateMessageDone() bool {
	if m.CreateMessageMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.CreateMessageMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.CreateMessageMock.invocationsDone()
}

// MinimockCreateMessageInspect logs each unmet expectation
func (m *ChatRepositoryIMock) MinimockCreateMessageInspect() {
	for _, e := range m.CreateMessageMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to ChatRepositoryIMock.CreateMessage at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterCreateMessageCounter := mm_atomic.LoadUint64(&m.afterCreateMessageCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.CreateMessageMock.defaultExpectation != nil && afterCreateMessageCounter < 1 {
		if m.CreateMessageMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to ChatRepositoryIMock.CreateMessage at\n%s", m.CreateMessageMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to ChatRepositoryIMock.CreateMessage at\n%s with params: %#v", m.CreateMessageMock.defaultExpectation.expectationOrigins.origin, *m.CreateMessageMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcCreateMessage != nil && afterCreateMessageCounter < 1 {
		m.t.Errorf("Expected call to ChatRepositoryIMock.CreateMessage at\n%s", m.funcCreateMessageOrigin)
	}

	if !m.CreateMessageMock.invocationsDone() && afterCreateMessageCounter > 0 {
		m.t.Errorf("Expected %d calls to ChatRepositoryIMock.CreateMessage at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.CreateMessageMock.expectedInvocations), m.CreateMessageMock.expectedInvocationsOrigin, afterCreateMessageCounter)
	}
}

type mChatRepositoryIMockCreateUser struct {
	optional           bool
	mock               *ChatRepositoryIMock
	defaultExpectation *ChatRepositoryIMockCreateUserExpectation
	expectations       []*ChatRepositoryIMockCreateUserExpectation

	callArgs []*ChatRepositoryIMockCreateUserParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// ChatRepositoryIMockCreateUserExpectation specifies expectation struct of the ChatRepositoryI.CreateUser
type ChatRepositoryIMockCreateUserExpectation struct {
	mock               *ChatRepositoryIMock
	params             *ChatRepositoryIMockCreateUserParams
	paramPtrs          *ChatRepositoryIMockCreateUserParamPtrs
	expectationOrigins ChatRepositoryIMockCreateUserExpectationOrigins
	results            *ChatRepositoryIMockCreateUserResults
	returnOrigin       string
	Counter            uint64
}

// ChatRepositoryIMockCreateUserParams contains parameters of the ChatRepositoryI.CreateUser
type ChatRepositoryIMockCreateUserParams struct {
	ctx  context.Context
	info *model.UserInfo
}

// ChatRepositoryIMockCreateUserParamPtrs contains pointers to parameters of the ChatRepositoryI.CreateUser
type ChatRepositoryIMockCreateUserParamPtrs struct {
	ctx  *context.Context
	info **model.UserInfo
}

// ChatRepositoryIMockCreateUserResults contains results of the ChatRepositoryI.CreateUser
type ChatRepositoryIMockCreateUserResults struct {
	i1  int64
	err error
}

// ChatRepositoryIMockCreateUserOrigins contains origins of expectations of the ChatRepositoryI.CreateUser
type ChatRepositoryIMockCreateUserExpectationOrigins struct {
	origin     string
	originCtx  string
	originInfo string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmCreateUser *mChatRepositoryIMockCreateUser) Optional() *mChatRepositoryIMockCreateUser {
	mmCreateUser.optional = true
	return mmCreateUser
}

// Expect sets up expected params for ChatRepositoryI.CreateUser
func (mmCreateUser *mChatRepositoryIMockCreateUser) Expect(ctx context.Context, info *model.UserInfo) *mChatRepositoryIMockCreateUser {
	if mmCreateUser.mock.funcCreateUser != nil {
		mmCreateUser.mock.t.Fatalf("ChatRepositoryIMock.CreateUser mock is already set by Set")
	}

	if mmCreateUser.defaultExpectation == nil {
		mmCreateUser.defaultExpectation = &ChatRepositoryIMockCreateUserExpectation{}
	}

	if mmCreateUser.defaultExpectation.paramPtrs != nil {
		mmCreateUser.mock.t.Fatalf("ChatRepositoryIMock.CreateUser mock is already set by ExpectParams functions")
	}

	mmCreateUser.defaultExpectation.params = &ChatRepositoryIMockCreateUserParams{ctx, info}
	mmCreateUser.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmCreateUser.expectations {
		if minimock.Equal(e.params, mmCreateUser.defaultExpectation.params) {
			mmCreateUser.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmCreateUser.defaultExpectation.params)
		}
	}

	return mmCreateUser
}

// ExpectCtxParam1 sets up expected param ctx for ChatRepositoryI.CreateUser
func (mmCreateUser *mChatRepositoryIMockCreateUser) ExpectCtxParam1(ctx context.Context) *mChatRepositoryIMockCreateUser {
	if mmCreateUser.mock.funcCreateUser != nil {
		mmCreateUser.mock.t.Fatalf("ChatRepositoryIMock.CreateUser mock is already set by Set")
	}

	if mmCreateUser.defaultExpectation == nil {
		mmCreateUser.defaultExpectation = &ChatRepositoryIMockCreateUserExpectation{}
	}

	if mmCreateUser.defaultExpectation.params != nil {
		mmCreateUser.mock.t.Fatalf("ChatRepositoryIMock.CreateUser mock is already set by Expect")
	}

	if mmCreateUser.defaultExpectation.paramPtrs == nil {
		mmCreateUser.defaultExpectation.paramPtrs = &ChatRepositoryIMockCreateUserParamPtrs{}
	}
	mmCreateUser.defaultExpectation.paramPtrs.ctx = &ctx
	mmCreateUser.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmCreateUser
}

// ExpectInfoParam2 sets up expected param info for ChatRepositoryI.CreateUser
func (mmCreateUser *mChatRepositoryIMockCreateUser) ExpectInfoParam2(info *model.UserInfo) *mChatRepositoryIMockCreateUser {
	if mmCreateUser.mock.funcCreateUser != nil {
		mmCreateUser.mock.t.Fatalf("ChatRepositoryIMock.CreateUser mock is already set by Set")
	}

	if mmCreateUser.defaultExpectation == nil {
		mmCreateUser.defaultExpectation = &ChatRepositoryIMockCreateUserExpectation{}
	}

	if mmCreateUser.defaultExpectation.params != nil {
		mmCreateUser.mock.t.Fatalf("ChatRepositoryIMock.CreateUser mock is already set by Expect")
	}

	if mmCreateUser.defaultExpectation.paramPtrs == nil {
		mmCreateUser.defaultExpectation.paramPtrs = &ChatRepositoryIMockCreateUserParamPtrs{}
	}
	mmCreateUser.defaultExpectation.paramPtrs.info = &info
	mmCreateUser.defaultExpectation.expectationOrigins.originInfo = minimock.CallerInfo(1)

	return mmCreateUser
}

// Inspect accepts an inspector function that has same arguments as the ChatRepositoryI.CreateUser
func (mmCreateUser *mChatRepositoryIMockCreateUser) Inspect(f func(ctx context.Context, info *model.UserInfo)) *mChatRepositoryIMockCreateUser {
	if mmCreateUser.mock.inspectFuncCreateUser != nil {
		mmCreateUser.mock.t.Fatalf("Inspect function is already set for ChatRepositoryIMock.CreateUser")
	}

	mmCreateUser.mock.inspectFuncCreateUser = f

	return mmCreateUser
}

// Return sets up results that will be returned by ChatRepositoryI.CreateUser
func (mmCreateUser *mChatRepositoryIMockCreateUser) Return(i1 int64, err error) *ChatRepositoryIMock {
	if mmCreateUser.mock.funcCreateUser != nil {
		mmCreateUser.mock.t.Fatalf("ChatRepositoryIMock.CreateUser mock is already set by Set")
	}

	if mmCreateUser.defaultExpectation == nil {
		mmCreateUser.defaultExpectation = &ChatRepositoryIMockCreateUserExpectation{mock: mmCreateUser.mock}
	}
	mmCreateUser.defaultExpectation.results = &ChatRepositoryIMockCreateUserResults{i1, err}
	mmCreateUser.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmCreateUser.mock
}

// Set uses given function f to mock the ChatRepositoryI.CreateUser method
func (mmCreateUser *mChatRepositoryIMockCreateUser) Set(f func(ctx context.Context, info *model.UserInfo) (i1 int64, err error)) *ChatRepositoryIMock {
	if mmCreateUser.defaultExpectation != nil {
		mmCreateUser.mock.t.Fatalf("Default expectation is already set for the ChatRepositoryI.CreateUser method")
	}

	if len(mmCreateUser.expectations) > 0 {
		mmCreateUser.mock.t.Fatalf("Some expectations are already set for the ChatRepositoryI.CreateUser method")
	}

	mmCreateUser.mock.funcCreateUser = f
	mmCreateUser.mock.funcCreateUserOrigin = minimock.CallerInfo(1)
	return mmCreateUser.mock
}

// When sets expectation for the ChatRepositoryI.CreateUser which will trigger the result defined by the following
// Then helper
func (mmCreateUser *mChatRepositoryIMockCreateUser) When(ctx context.Context, info *model.UserInfo) *ChatRepositoryIMockCreateUserExpectation {
	if mmCreateUser.mock.funcCreateUser != nil {
		mmCreateUser.mock.t.Fatalf("ChatRepositoryIMock.CreateUser mock is already set by Set")
	}

	expectation := &ChatRepositoryIMockCreateUserExpectation{
		mock:               mmCreateUser.mock,
		params:             &ChatRepositoryIMockCreateUserParams{ctx, info},
		expectationOrigins: ChatRepositoryIMockCreateUserExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmCreateUser.expectations = append(mmCreateUser.expectations, expectation)
	return expectation
}

// Then sets up ChatRepositoryI.CreateUser return parameters for the expectation previously defined by the When method
func (e *ChatRepositoryIMockCreateUserExpectation) Then(i1 int64, err error) *ChatRepositoryIMock {
	e.results = &ChatRepositoryIMockCreateUserResults{i1, err}
	return e.mock
}

// Times sets number of times ChatRepositoryI.CreateUser should be invoked
func (mmCreateUser *mChatRepositoryIMockCreateUser) Times(n uint64) *mChatRepositoryIMockCreateUser {
	if n == 0 {
		mmCreateUser.mock.t.Fatalf("Times of ChatRepositoryIMock.CreateUser mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmCreateUser.expectedInvocations, n)
	mmCreateUser.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmCreateUser
}

func (mmCreateUser *mChatRepositoryIMockCreateUser) invocationsDone() bool {
	if len(mmCreateUser.expectations) == 0 && mmCreateUser.defaultExpectation == nil && mmCreateUser.mock.funcCreateUser == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmCreateUser.mock.afterCreateUserCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmCreateUser.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// CreateUser implements mm_repository.ChatRepositoryI
func (mmCreateUser *ChatRepositoryIMock) CreateUser(ctx context.Context, info *model.UserInfo) (i1 int64, err error) {
	mm_atomic.AddUint64(&mmCreateUser.beforeCreateUserCounter, 1)
	defer mm_atomic.AddUint64(&mmCreateUser.afterCreateUserCounter, 1)

	mmCreateUser.t.Helper()

	if mmCreateUser.inspectFuncCreateUser != nil {
		mmCreateUser.inspectFuncCreateUser(ctx, info)
	}

	mm_params := ChatRepositoryIMockCreateUserParams{ctx, info}

	// Record call args
	mmCreateUser.CreateUserMock.mutex.Lock()
	mmCreateUser.CreateUserMock.callArgs = append(mmCreateUser.CreateUserMock.callArgs, &mm_params)
	mmCreateUser.CreateUserMock.mutex.Unlock()

	for _, e := range mmCreateUser.CreateUserMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.i1, e.results.err
		}
	}

	if mmCreateUser.CreateUserMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmCreateUser.CreateUserMock.defaultExpectation.Counter, 1)
		mm_want := mmCreateUser.CreateUserMock.defaultExpectation.params
		mm_want_ptrs := mmCreateUser.CreateUserMock.defaultExpectation.paramPtrs

		mm_got := ChatRepositoryIMockCreateUserParams{ctx, info}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmCreateUser.t.Errorf("ChatRepositoryIMock.CreateUser got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmCreateUser.CreateUserMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.info != nil && !minimock.Equal(*mm_want_ptrs.info, mm_got.info) {
				mmCreateUser.t.Errorf("ChatRepositoryIMock.CreateUser got unexpected parameter info, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmCreateUser.CreateUserMock.defaultExpectation.expectationOrigins.originInfo, *mm_want_ptrs.info, mm_got.info, minimock.Diff(*mm_want_ptrs.info, mm_got.info))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmCreateUser.t.Errorf("ChatRepositoryIMock.CreateUser got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmCreateUser.CreateUserMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmCreateUser.CreateUserMock.defaultExpectation.results
		if mm_results == nil {
			mmCreateUser.t.Fatal("No results are set for the ChatRepositoryIMock.CreateUser")
		}
		return (*mm_results).i1, (*mm_results).err
	}
	if mmCreateUser.funcCreateUser != nil {
		return mmCreateUser.funcCreateUser(ctx, info)
	}
	mmCreateUser.t.Fatalf("Unexpected call to ChatRepositoryIMock.CreateUser. %v %v", ctx, info)
	return
}

// CreateUserAfterCounter returns a count of finished ChatRepositoryIMock.CreateUser invocations
func (mmCreateUser *ChatRepositoryIMock) CreateUserAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmCreateUser.afterCreateUserCounter)
}

// CreateUserBeforeCounter returns a count of ChatRepositoryIMock.CreateUser invocations
func (mmCreateUser *ChatRepositoryIMock) CreateUserBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmCreateUser.beforeCreateUserCounter)
}

// Calls returns a list of arguments used in each call to ChatRepositoryIMock.CreateUser.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmCreateUser *mChatRepositoryIMockCreateUser) Calls() []*ChatRepositoryIMockCreateUserParams {
	mmCreateUser.mutex.RLock()

	argCopy := make([]*ChatRepositoryIMockCreateUserParams, len(mmCreateUser.callArgs))
	copy(argCopy, mmCreateUser.callArgs)

	mmCreateUser.mutex.RUnlock()

	return argCopy
}

// MinimockCreateUserDone returns true if the count of the CreateUser invocations corresponds
// the number of defined expectations
func (m *ChatRepositoryIMock) MinimockCreateUserDone() bool {
	if m.CreateUserMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.CreateUserMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.CreateUserMock.invocationsDone()
}

// MinimockCreateUserInspect logs each unmet expectation
func (m *ChatRepositoryIMock) MinimockCreateUserInspect() {
	for _, e := range m.CreateUserMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to ChatRepositoryIMock.CreateUser at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterCreateUserCounter := mm_atomic.LoadUint64(&m.afterCreateUserCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.CreateUserMock.defaultExpectation != nil && afterCreateUserCounter < 1 {
		if m.CreateUserMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to ChatRepositoryIMock.CreateUser at\n%s", m.CreateUserMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to ChatRepositoryIMock.CreateUser at\n%s with params: %#v", m.CreateUserMock.defaultExpectation.expectationOrigins.origin, *m.CreateUserMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcCreateUser != nil && afterCreateUserCounter < 1 {
		m.t.Errorf("Expected call to ChatRepositoryIMock.CreateUser at\n%s", m.funcCreateUserOrigin)
	}

	if !m.CreateUserMock.invocationsDone() && afterCreateUserCounter > 0 {
		m.t.Errorf("Expected %d calls to ChatRepositoryIMock.CreateUser at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.CreateUserMock.expectedInvocations), m.CreateUserMock.expectedInvocationsOrigin, afterCreateUserCounter)
	}
}

type mChatRepositoryIMockDeleteChat struct {
	optional           bool
	mock               *ChatRepositoryIMock
	defaultExpectation *ChatRepositoryIMockDeleteChatExpectation
	expectations       []*ChatRepositoryIMockDeleteChatExpectation

	callArgs []*ChatRepositoryIMockDeleteChatParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// ChatRepositoryIMockDeleteChatExpectation specifies expectation struct of the ChatRepositoryI.DeleteChat
type ChatRepositoryIMockDeleteChatExpectation struct {
	mock               *ChatRepositoryIMock
	params             *ChatRepositoryIMockDeleteChatParams
	paramPtrs          *ChatRepositoryIMockDeleteChatParamPtrs
	expectationOrigins ChatRepositoryIMockDeleteChatExpectationOrigins
	results            *ChatRepositoryIMockDeleteChatResults
	returnOrigin       string
	Counter            uint64
}

// ChatRepositoryIMockDeleteChatParams contains parameters of the ChatRepositoryI.DeleteChat
type ChatRepositoryIMockDeleteChatParams struct {
	ctx context.Context
	id  int64
}

// ChatRepositoryIMockDeleteChatParamPtrs contains pointers to parameters of the ChatRepositoryI.DeleteChat
type ChatRepositoryIMockDeleteChatParamPtrs struct {
	ctx *context.Context
	id  *int64
}

// ChatRepositoryIMockDeleteChatResults contains results of the ChatRepositoryI.DeleteChat
type ChatRepositoryIMockDeleteChatResults struct {
	err error
}

// ChatRepositoryIMockDeleteChatOrigins contains origins of expectations of the ChatRepositoryI.DeleteChat
type ChatRepositoryIMockDeleteChatExpectationOrigins struct {
	origin    string
	originCtx string
	originId  string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmDeleteChat *mChatRepositoryIMockDeleteChat) Optional() *mChatRepositoryIMockDeleteChat {
	mmDeleteChat.optional = true
	return mmDeleteChat
}

// Expect sets up expected params for ChatRepositoryI.DeleteChat
func (mmDeleteChat *mChatRepositoryIMockDeleteChat) Expect(ctx context.Context, id int64) *mChatRepositoryIMockDeleteChat {
	if mmDeleteChat.mock.funcDeleteChat != nil {
		mmDeleteChat.mock.t.Fatalf("ChatRepositoryIMock.DeleteChat mock is already set by Set")
	}

	if mmDeleteChat.defaultExpectation == nil {
		mmDeleteChat.defaultExpectation = &ChatRepositoryIMockDeleteChatExpectation{}
	}

	if mmDeleteChat.defaultExpectation.paramPtrs != nil {
		mmDeleteChat.mock.t.Fatalf("ChatRepositoryIMock.DeleteChat mock is already set by ExpectParams functions")
	}

	mmDeleteChat.defaultExpectation.params = &ChatRepositoryIMockDeleteChatParams{ctx, id}
	mmDeleteChat.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmDeleteChat.expectations {
		if minimock.Equal(e.params, mmDeleteChat.defaultExpectation.params) {
			mmDeleteChat.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmDeleteChat.defaultExpectation.params)
		}
	}

	return mmDeleteChat
}

// ExpectCtxParam1 sets up expected param ctx for ChatRepositoryI.DeleteChat
func (mmDeleteChat *mChatRepositoryIMockDeleteChat) ExpectCtxParam1(ctx context.Context) *mChatRepositoryIMockDeleteChat {
	if mmDeleteChat.mock.funcDeleteChat != nil {
		mmDeleteChat.mock.t.Fatalf("ChatRepositoryIMock.DeleteChat mock is already set by Set")
	}

	if mmDeleteChat.defaultExpectation == nil {
		mmDeleteChat.defaultExpectation = &ChatRepositoryIMockDeleteChatExpectation{}
	}

	if mmDeleteChat.defaultExpectation.params != nil {
		mmDeleteChat.mock.t.Fatalf("ChatRepositoryIMock.DeleteChat mock is already set by Expect")
	}

	if mmDeleteChat.defaultExpectation.paramPtrs == nil {
		mmDeleteChat.defaultExpectation.paramPtrs = &ChatRepositoryIMockDeleteChatParamPtrs{}
	}
	mmDeleteChat.defaultExpectation.paramPtrs.ctx = &ctx
	mmDeleteChat.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmDeleteChat
}

// ExpectIdParam2 sets up expected param id for ChatRepositoryI.DeleteChat
func (mmDeleteChat *mChatRepositoryIMockDeleteChat) ExpectIdParam2(id int64) *mChatRepositoryIMockDeleteChat {
	if mmDeleteChat.mock.funcDeleteChat != nil {
		mmDeleteChat.mock.t.Fatalf("ChatRepositoryIMock.DeleteChat mock is already set by Set")
	}

	if mmDeleteChat.defaultExpectation == nil {
		mmDeleteChat.defaultExpectation = &ChatRepositoryIMockDeleteChatExpectation{}
	}

	if mmDeleteChat.defaultExpectation.params != nil {
		mmDeleteChat.mock.t.Fatalf("ChatRepositoryIMock.DeleteChat mock is already set by Expect")
	}

	if mmDeleteChat.defaultExpectation.paramPtrs == nil {
		mmDeleteChat.defaultExpectation.paramPtrs = &ChatRepositoryIMockDeleteChatParamPtrs{}
	}
	mmDeleteChat.defaultExpectation.paramPtrs.id = &id
	mmDeleteChat.defaultExpectation.expectationOrigins.originId = minimock.CallerInfo(1)

	return mmDeleteChat
}

// Inspect accepts an inspector function that has same arguments as the ChatRepositoryI.DeleteChat
func (mmDeleteChat *mChatRepositoryIMockDeleteChat) Inspect(f func(ctx context.Context, id int64)) *mChatRepositoryIMockDeleteChat {
	if mmDeleteChat.mock.inspectFuncDeleteChat != nil {
		mmDeleteChat.mock.t.Fatalf("Inspect function is already set for ChatRepositoryIMock.DeleteChat")
	}

	mmDeleteChat.mock.inspectFuncDeleteChat = f

	return mmDeleteChat
}

// Return sets up results that will be returned by ChatRepositoryI.DeleteChat
func (mmDeleteChat *mChatRepositoryIMockDeleteChat) Return(err error) *ChatRepositoryIMock {
	if mmDeleteChat.mock.funcDeleteChat != nil {
		mmDeleteChat.mock.t.Fatalf("ChatRepositoryIMock.DeleteChat mock is already set by Set")
	}

	if mmDeleteChat.defaultExpectation == nil {
		mmDeleteChat.defaultExpectation = &ChatRepositoryIMockDeleteChatExpectation{mock: mmDeleteChat.mock}
	}
	mmDeleteChat.defaultExpectation.results = &ChatRepositoryIMockDeleteChatResults{err}
	mmDeleteChat.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmDeleteChat.mock
}

// Set uses given function f to mock the ChatRepositoryI.DeleteChat method
func (mmDeleteChat *mChatRepositoryIMockDeleteChat) Set(f func(ctx context.Context, id int64) (err error)) *ChatRepositoryIMock {
	if mmDeleteChat.defaultExpectation != nil {
		mmDeleteChat.mock.t.Fatalf("Default expectation is already set for the ChatRepositoryI.DeleteChat method")
	}

	if len(mmDeleteChat.expectations) > 0 {
		mmDeleteChat.mock.t.Fatalf("Some expectations are already set for the ChatRepositoryI.DeleteChat method")
	}

	mmDeleteChat.mock.funcDeleteChat = f
	mmDeleteChat.mock.funcDeleteChatOrigin = minimock.CallerInfo(1)
	return mmDeleteChat.mock
}

// When sets expectation for the ChatRepositoryI.DeleteChat which will trigger the result defined by the following
// Then helper
func (mmDeleteChat *mChatRepositoryIMockDeleteChat) When(ctx context.Context, id int64) *ChatRepositoryIMockDeleteChatExpectation {
	if mmDeleteChat.mock.funcDeleteChat != nil {
		mmDeleteChat.mock.t.Fatalf("ChatRepositoryIMock.DeleteChat mock is already set by Set")
	}

	expectation := &ChatRepositoryIMockDeleteChatExpectation{
		mock:               mmDeleteChat.mock,
		params:             &ChatRepositoryIMockDeleteChatParams{ctx, id},
		expectationOrigins: ChatRepositoryIMockDeleteChatExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmDeleteChat.expectations = append(mmDeleteChat.expectations, expectation)
	return expectation
}

// Then sets up ChatRepositoryI.DeleteChat return parameters for the expectation previously defined by the When method
func (e *ChatRepositoryIMockDeleteChatExpectation) Then(err error) *ChatRepositoryIMock {
	e.results = &ChatRepositoryIMockDeleteChatResults{err}
	return e.mock
}

// Times sets number of times ChatRepositoryI.DeleteChat should be invoked
func (mmDeleteChat *mChatRepositoryIMockDeleteChat) Times(n uint64) *mChatRepositoryIMockDeleteChat {
	if n == 0 {
		mmDeleteChat.mock.t.Fatalf("Times of ChatRepositoryIMock.DeleteChat mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmDeleteChat.expectedInvocations, n)
	mmDeleteChat.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmDeleteChat
}

func (mmDeleteChat *mChatRepositoryIMockDeleteChat) invocationsDone() bool {
	if len(mmDeleteChat.expectations) == 0 && mmDeleteChat.defaultExpectation == nil && mmDeleteChat.mock.funcDeleteChat == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmDeleteChat.mock.afterDeleteChatCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmDeleteChat.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// DeleteChat implements mm_repository.ChatRepositoryI
func (mmDeleteChat *ChatRepositoryIMock) DeleteChat(ctx context.Context, id int64) (err error) {
	mm_atomic.AddUint64(&mmDeleteChat.beforeDeleteChatCounter, 1)
	defer mm_atomic.AddUint64(&mmDeleteChat.afterDeleteChatCounter, 1)

	mmDeleteChat.t.Helper()

	if mmDeleteChat.inspectFuncDeleteChat != nil {
		mmDeleteChat.inspectFuncDeleteChat(ctx, id)
	}

	mm_params := ChatRepositoryIMockDeleteChatParams{ctx, id}

	// Record call args
	mmDeleteChat.DeleteChatMock.mutex.Lock()
	mmDeleteChat.DeleteChatMock.callArgs = append(mmDeleteChat.DeleteChatMock.callArgs, &mm_params)
	mmDeleteChat.DeleteChatMock.mutex.Unlock()

	for _, e := range mmDeleteChat.DeleteChatMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmDeleteChat.DeleteChatMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmDeleteChat.DeleteChatMock.defaultExpectation.Counter, 1)
		mm_want := mmDeleteChat.DeleteChatMock.defaultExpectation.params
		mm_want_ptrs := mmDeleteChat.DeleteChatMock.defaultExpectation.paramPtrs

		mm_got := ChatRepositoryIMockDeleteChatParams{ctx, id}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmDeleteChat.t.Errorf("ChatRepositoryIMock.DeleteChat got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmDeleteChat.DeleteChatMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.id != nil && !minimock.Equal(*mm_want_ptrs.id, mm_got.id) {
				mmDeleteChat.t.Errorf("ChatRepositoryIMock.DeleteChat got unexpected parameter id, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmDeleteChat.DeleteChatMock.defaultExpectation.expectationOrigins.originId, *mm_want_ptrs.id, mm_got.id, minimock.Diff(*mm_want_ptrs.id, mm_got.id))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmDeleteChat.t.Errorf("ChatRepositoryIMock.DeleteChat got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmDeleteChat.DeleteChatMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmDeleteChat.DeleteChatMock.defaultExpectation.results
		if mm_results == nil {
			mmDeleteChat.t.Fatal("No results are set for the ChatRepositoryIMock.DeleteChat")
		}
		return (*mm_results).err
	}
	if mmDeleteChat.funcDeleteChat != nil {
		return mmDeleteChat.funcDeleteChat(ctx, id)
	}
	mmDeleteChat.t.Fatalf("Unexpected call to ChatRepositoryIMock.DeleteChat. %v %v", ctx, id)
	return
}

// DeleteChatAfterCounter returns a count of finished ChatRepositoryIMock.DeleteChat invocations
func (mmDeleteChat *ChatRepositoryIMock) DeleteChatAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmDeleteChat.afterDeleteChatCounter)
}

// DeleteChatBeforeCounter returns a count of ChatRepositoryIMock.DeleteChat invocations
func (mmDeleteChat *ChatRepositoryIMock) DeleteChatBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmDeleteChat.beforeDeleteChatCounter)
}

// Calls returns a list of arguments used in each call to ChatRepositoryIMock.DeleteChat.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmDeleteChat *mChatRepositoryIMockDeleteChat) Calls() []*ChatRepositoryIMockDeleteChatParams {
	mmDeleteChat.mutex.RLock()

	argCopy := make([]*ChatRepositoryIMockDeleteChatParams, len(mmDeleteChat.callArgs))
	copy(argCopy, mmDeleteChat.callArgs)

	mmDeleteChat.mutex.RUnlock()

	return argCopy
}

// MinimockDeleteChatDone returns true if the count of the DeleteChat invocations corresponds
// the number of defined expectations
func (m *ChatRepositoryIMock) MinimockDeleteChatDone() bool {
	if m.DeleteChatMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.DeleteChatMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.DeleteChatMock.invocationsDone()
}

// MinimockDeleteChatInspect logs each unmet expectation
func (m *ChatRepositoryIMock) MinimockDeleteChatInspect() {
	for _, e := range m.DeleteChatMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to ChatRepositoryIMock.DeleteChat at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterDeleteChatCounter := mm_atomic.LoadUint64(&m.afterDeleteChatCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.DeleteChatMock.defaultExpectation != nil && afterDeleteChatCounter < 1 {
		if m.DeleteChatMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to ChatRepositoryIMock.DeleteChat at\n%s", m.DeleteChatMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to ChatRepositoryIMock.DeleteChat at\n%s with params: %#v", m.DeleteChatMock.defaultExpectation.expectationOrigins.origin, *m.DeleteChatMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcDeleteChat != nil && afterDeleteChatCounter < 1 {
		m.t.Errorf("Expected call to ChatRepositoryIMock.DeleteChat at\n%s", m.funcDeleteChatOrigin)
	}

	if !m.DeleteChatMock.invocationsDone() && afterDeleteChatCounter > 0 {
		m.t.Errorf("Expected %d calls to ChatRepositoryIMock.DeleteChat at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.DeleteChatMock.expectedInvocations), m.DeleteChatMock.expectedInvocationsOrigin, afterDeleteChatCounter)
	}
}

type mChatRepositoryIMockDeleteUser struct {
	optional           bool
	mock               *ChatRepositoryIMock
	defaultExpectation *ChatRepositoryIMockDeleteUserExpectation
	expectations       []*ChatRepositoryIMockDeleteUserExpectation

	callArgs []*ChatRepositoryIMockDeleteUserParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// ChatRepositoryIMockDeleteUserExpectation specifies expectation struct of the ChatRepositoryI.DeleteUser
type ChatRepositoryIMockDeleteUserExpectation struct {
	mock               *ChatRepositoryIMock
	params             *ChatRepositoryIMockDeleteUserParams
	paramPtrs          *ChatRepositoryIMockDeleteUserParamPtrs
	expectationOrigins ChatRepositoryIMockDeleteUserExpectationOrigins
	results            *ChatRepositoryIMockDeleteUserResults
	returnOrigin       string
	Counter            uint64
}

// ChatRepositoryIMockDeleteUserParams contains parameters of the ChatRepositoryI.DeleteUser
type ChatRepositoryIMockDeleteUserParams struct {
	ctx context.Context
	id  int64
}

// ChatRepositoryIMockDeleteUserParamPtrs contains pointers to parameters of the ChatRepositoryI.DeleteUser
type ChatRepositoryIMockDeleteUserParamPtrs struct {
	ctx *context.Context
	id  *int64
}

// ChatRepositoryIMockDeleteUserResults contains results of the ChatRepositoryI.DeleteUser
type ChatRepositoryIMockDeleteUserResults struct {
	err error
}

// ChatRepositoryIMockDeleteUserOrigins contains origins of expectations of the ChatRepositoryI.DeleteUser
type ChatRepositoryIMockDeleteUserExpectationOrigins struct {
	origin    string
	originCtx string
	originId  string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmDeleteUser *mChatRepositoryIMockDeleteUser) Optional() *mChatRepositoryIMockDeleteUser {
	mmDeleteUser.optional = true
	return mmDeleteUser
}

// Expect sets up expected params for ChatRepositoryI.DeleteUser
func (mmDeleteUser *mChatRepositoryIMockDeleteUser) Expect(ctx context.Context, id int64) *mChatRepositoryIMockDeleteUser {
	if mmDeleteUser.mock.funcDeleteUser != nil {
		mmDeleteUser.mock.t.Fatalf("ChatRepositoryIMock.DeleteUser mock is already set by Set")
	}

	if mmDeleteUser.defaultExpectation == nil {
		mmDeleteUser.defaultExpectation = &ChatRepositoryIMockDeleteUserExpectation{}
	}

	if mmDeleteUser.defaultExpectation.paramPtrs != nil {
		mmDeleteUser.mock.t.Fatalf("ChatRepositoryIMock.DeleteUser mock is already set by ExpectParams functions")
	}

	mmDeleteUser.defaultExpectation.params = &ChatRepositoryIMockDeleteUserParams{ctx, id}
	mmDeleteUser.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmDeleteUser.expectations {
		if minimock.Equal(e.params, mmDeleteUser.defaultExpectation.params) {
			mmDeleteUser.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmDeleteUser.defaultExpectation.params)
		}
	}

	return mmDeleteUser
}

// ExpectCtxParam1 sets up expected param ctx for ChatRepositoryI.DeleteUser
func (mmDeleteUser *mChatRepositoryIMockDeleteUser) ExpectCtxParam1(ctx context.Context) *mChatRepositoryIMockDeleteUser {
	if mmDeleteUser.mock.funcDeleteUser != nil {
		mmDeleteUser.mock.t.Fatalf("ChatRepositoryIMock.DeleteUser mock is already set by Set")
	}

	if mmDeleteUser.defaultExpectation == nil {
		mmDeleteUser.defaultExpectation = &ChatRepositoryIMockDeleteUserExpectation{}
	}

	if mmDeleteUser.defaultExpectation.params != nil {
		mmDeleteUser.mock.t.Fatalf("ChatRepositoryIMock.DeleteUser mock is already set by Expect")
	}

	if mmDeleteUser.defaultExpectation.paramPtrs == nil {
		mmDeleteUser.defaultExpectation.paramPtrs = &ChatRepositoryIMockDeleteUserParamPtrs{}
	}
	mmDeleteUser.defaultExpectation.paramPtrs.ctx = &ctx
	mmDeleteUser.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmDeleteUser
}

// ExpectIdParam2 sets up expected param id for ChatRepositoryI.DeleteUser
func (mmDeleteUser *mChatRepositoryIMockDeleteUser) ExpectIdParam2(id int64) *mChatRepositoryIMockDeleteUser {
	if mmDeleteUser.mock.funcDeleteUser != nil {
		mmDeleteUser.mock.t.Fatalf("ChatRepositoryIMock.DeleteUser mock is already set by Set")
	}

	if mmDeleteUser.defaultExpectation == nil {
		mmDeleteUser.defaultExpectation = &ChatRepositoryIMockDeleteUserExpectation{}
	}

	if mmDeleteUser.defaultExpectation.params != nil {
		mmDeleteUser.mock.t.Fatalf("ChatRepositoryIMock.DeleteUser mock is already set by Expect")
	}

	if mmDeleteUser.defaultExpectation.paramPtrs == nil {
		mmDeleteUser.defaultExpectation.paramPtrs = &ChatRepositoryIMockDeleteUserParamPtrs{}
	}
	mmDeleteUser.defaultExpectation.paramPtrs.id = &id
	mmDeleteUser.defaultExpectation.expectationOrigins.originId = minimock.CallerInfo(1)

	return mmDeleteUser
}

// Inspect accepts an inspector function that has same arguments as the ChatRepositoryI.DeleteUser
func (mmDeleteUser *mChatRepositoryIMockDeleteUser) Inspect(f func(ctx context.Context, id int64)) *mChatRepositoryIMockDeleteUser {
	if mmDeleteUser.mock.inspectFuncDeleteUser != nil {
		mmDeleteUser.mock.t.Fatalf("Inspect function is already set for ChatRepositoryIMock.DeleteUser")
	}

	mmDeleteUser.mock.inspectFuncDeleteUser = f

	return mmDeleteUser
}

// Return sets up results that will be returned by ChatRepositoryI.DeleteUser
func (mmDeleteUser *mChatRepositoryIMockDeleteUser) Return(err error) *ChatRepositoryIMock {
	if mmDeleteUser.mock.funcDeleteUser != nil {
		mmDeleteUser.mock.t.Fatalf("ChatRepositoryIMock.DeleteUser mock is already set by Set")
	}

	if mmDeleteUser.defaultExpectation == nil {
		mmDeleteUser.defaultExpectation = &ChatRepositoryIMockDeleteUserExpectation{mock: mmDeleteUser.mock}
	}
	mmDeleteUser.defaultExpectation.results = &ChatRepositoryIMockDeleteUserResults{err}
	mmDeleteUser.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmDeleteUser.mock
}

// Set uses given function f to mock the ChatRepositoryI.DeleteUser method
func (mmDeleteUser *mChatRepositoryIMockDeleteUser) Set(f func(ctx context.Context, id int64) (err error)) *ChatRepositoryIMock {
	if mmDeleteUser.defaultExpectation != nil {
		mmDeleteUser.mock.t.Fatalf("Default expectation is already set for the ChatRepositoryI.DeleteUser method")
	}

	if len(mmDeleteUser.expectations) > 0 {
		mmDeleteUser.mock.t.Fatalf("Some expectations are already set for the ChatRepositoryI.DeleteUser method")
	}

	mmDeleteUser.mock.funcDeleteUser = f
	mmDeleteUser.mock.funcDeleteUserOrigin = minimock.CallerInfo(1)
	return mmDeleteUser.mock
}

// When sets expectation for the ChatRepositoryI.DeleteUser which will trigger the result defined by the following
// Then helper
func (mmDeleteUser *mChatRepositoryIMockDeleteUser) When(ctx context.Context, id int64) *ChatRepositoryIMockDeleteUserExpectation {
	if mmDeleteUser.mock.funcDeleteUser != nil {
		mmDeleteUser.mock.t.Fatalf("ChatRepositoryIMock.DeleteUser mock is already set by Set")
	}

	expectation := &ChatRepositoryIMockDeleteUserExpectation{
		mock:               mmDeleteUser.mock,
		params:             &ChatRepositoryIMockDeleteUserParams{ctx, id},
		expectationOrigins: ChatRepositoryIMockDeleteUserExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmDeleteUser.expectations = append(mmDeleteUser.expectations, expectation)
	return expectation
}

// Then sets up ChatRepositoryI.DeleteUser return parameters for the expectation previously defined by the When method
func (e *ChatRepositoryIMockDeleteUserExpectation) Then(err error) *ChatRepositoryIMock {
	e.results = &ChatRepositoryIMockDeleteUserResults{err}
	return e.mock
}

// Times sets number of times ChatRepositoryI.DeleteUser should be invoked
func (mmDeleteUser *mChatRepositoryIMockDeleteUser) Times(n uint64) *mChatRepositoryIMockDeleteUser {
	if n == 0 {
		mmDeleteUser.mock.t.Fatalf("Times of ChatRepositoryIMock.DeleteUser mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmDeleteUser.expectedInvocations, n)
	mmDeleteUser.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmDeleteUser
}

func (mmDeleteUser *mChatRepositoryIMockDeleteUser) invocationsDone() bool {
	if len(mmDeleteUser.expectations) == 0 && mmDeleteUser.defaultExpectation == nil && mmDeleteUser.mock.funcDeleteUser == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmDeleteUser.mock.afterDeleteUserCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmDeleteUser.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// DeleteUser implements mm_repository.ChatRepositoryI
func (mmDeleteUser *ChatRepositoryIMock) DeleteUser(ctx context.Context, id int64) (err error) {
	mm_atomic.AddUint64(&mmDeleteUser.beforeDeleteUserCounter, 1)
	defer mm_atomic.AddUint64(&mmDeleteUser.afterDeleteUserCounter, 1)

	mmDeleteUser.t.Helper()

	if mmDeleteUser.inspectFuncDeleteUser != nil {
		mmDeleteUser.inspectFuncDeleteUser(ctx, id)
	}

	mm_params := ChatRepositoryIMockDeleteUserParams{ctx, id}

	// Record call args
	mmDeleteUser.DeleteUserMock.mutex.Lock()
	mmDeleteUser.DeleteUserMock.callArgs = append(mmDeleteUser.DeleteUserMock.callArgs, &mm_params)
	mmDeleteUser.DeleteUserMock.mutex.Unlock()

	for _, e := range mmDeleteUser.DeleteUserMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmDeleteUser.DeleteUserMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmDeleteUser.DeleteUserMock.defaultExpectation.Counter, 1)
		mm_want := mmDeleteUser.DeleteUserMock.defaultExpectation.params
		mm_want_ptrs := mmDeleteUser.DeleteUserMock.defaultExpectation.paramPtrs

		mm_got := ChatRepositoryIMockDeleteUserParams{ctx, id}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmDeleteUser.t.Errorf("ChatRepositoryIMock.DeleteUser got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmDeleteUser.DeleteUserMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.id != nil && !minimock.Equal(*mm_want_ptrs.id, mm_got.id) {
				mmDeleteUser.t.Errorf("ChatRepositoryIMock.DeleteUser got unexpected parameter id, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmDeleteUser.DeleteUserMock.defaultExpectation.expectationOrigins.originId, *mm_want_ptrs.id, mm_got.id, minimock.Diff(*mm_want_ptrs.id, mm_got.id))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmDeleteUser.t.Errorf("ChatRepositoryIMock.DeleteUser got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmDeleteUser.DeleteUserMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmDeleteUser.DeleteUserMock.defaultExpectation.results
		if mm_results == nil {
			mmDeleteUser.t.Fatal("No results are set for the ChatRepositoryIMock.DeleteUser")
		}
		return (*mm_results).err
	}
	if mmDeleteUser.funcDeleteUser != nil {
		return mmDeleteUser.funcDeleteUser(ctx, id)
	}
	mmDeleteUser.t.Fatalf("Unexpected call to ChatRepositoryIMock.DeleteUser. %v %v", ctx, id)
	return
}

// DeleteUserAfterCounter returns a count of finished ChatRepositoryIMock.DeleteUser invocations
func (mmDeleteUser *ChatRepositoryIMock) DeleteUserAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmDeleteUser.afterDeleteUserCounter)
}

// DeleteUserBeforeCounter returns a count of ChatRepositoryIMock.DeleteUser invocations
func (mmDeleteUser *ChatRepositoryIMock) DeleteUserBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmDeleteUser.beforeDeleteUserCounter)
}

// Calls returns a list of arguments used in each call to ChatRepositoryIMock.DeleteUser.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmDeleteUser *mChatRepositoryIMockDeleteUser) Calls() []*ChatRepositoryIMockDeleteUserParams {
	mmDeleteUser.mutex.RLock()

	argCopy := make([]*ChatRepositoryIMockDeleteUserParams, len(mmDeleteUser.callArgs))
	copy(argCopy, mmDeleteUser.callArgs)

	mmDeleteUser.mutex.RUnlock()

	return argCopy
}

// MinimockDeleteUserDone returns true if the count of the DeleteUser invocations corresponds
// the number of defined expectations
func (m *ChatRepositoryIMock) MinimockDeleteUserDone() bool {
	if m.DeleteUserMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.DeleteUserMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.DeleteUserMock.invocationsDone()
}

// MinimockDeleteUserInspect logs each unmet expectation
func (m *ChatRepositoryIMock) MinimockDeleteUserInspect() {
	for _, e := range m.DeleteUserMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to ChatRepositoryIMock.DeleteUser at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterDeleteUserCounter := mm_atomic.LoadUint64(&m.afterDeleteUserCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.DeleteUserMock.defaultExpectation != nil && afterDeleteUserCounter < 1 {
		if m.DeleteUserMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to ChatRepositoryIMock.DeleteUser at\n%s", m.DeleteUserMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to ChatRepositoryIMock.DeleteUser at\n%s with params: %#v", m.DeleteUserMock.defaultExpectation.expectationOrigins.origin, *m.DeleteUserMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcDeleteUser != nil && afterDeleteUserCounter < 1 {
		m.t.Errorf("Expected call to ChatRepositoryIMock.DeleteUser at\n%s", m.funcDeleteUserOrigin)
	}

	if !m.DeleteUserMock.invocationsDone() && afterDeleteUserCounter > 0 {
		m.t.Errorf("Expected %d calls to ChatRepositoryIMock.DeleteUser at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.DeleteUserMock.expectedInvocations), m.DeleteUserMock.expectedInvocationsOrigin, afterDeleteUserCounter)
	}
}

// MinimockFinish checks that all mocked methods have been called the expected number of times
func (m *ChatRepositoryIMock) MinimockFinish() {
	m.finishOnce.Do(func() {
		if !m.minimockDone() {
			m.MinimockAddUsersToChatInspect()

			m.MinimockCreateChatInspect()

			m.MinimockCreateMessageInspect()

			m.MinimockCreateUserInspect()

			m.MinimockDeleteChatInspect()

			m.MinimockDeleteUserInspect()
		}
	})
}

// MinimockWait waits for all mocked methods to be called the expected number of times
func (m *ChatRepositoryIMock) MinimockWait(timeout mm_time.Duration) {
	timeoutCh := mm_time.After(timeout)
	for {
		if m.minimockDone() {
			return
		}
		select {
		case <-timeoutCh:
			m.MinimockFinish()
			return
		case <-mm_time.After(10 * mm_time.Millisecond):
		}
	}
}

func (m *ChatRepositoryIMock) minimockDone() bool {
	done := true
	return done &&
		m.MinimockAddUsersToChatDone() &&
		m.MinimockCreateChatDone() &&
		m.MinimockCreateMessageDone() &&
		m.MinimockCreateUserDone() &&
		m.MinimockDeleteChatDone() &&
		m.MinimockDeleteUserDone()
}
