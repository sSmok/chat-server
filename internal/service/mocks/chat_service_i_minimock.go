// Code generated by http://github.com/gojuno/minimock (v3.4.3). DO NOT EDIT.

package mocks

//go:generate minimock -i github.com/sSmok/chat-server/internal/service.ChatServiceI -o chat_service_i_minimock.go -n ChatServiceIMock -p mocks

import (
	"context"
	"sync"
	mm_atomic "sync/atomic"
	mm_time "time"

	"github.com/gojuno/minimock/v3"
	"github.com/sSmok/chat-server/internal/model"
)

// ChatServiceIMock implements mm_service.ChatServiceI
type ChatServiceIMock struct {
	t          minimock.Tester
	finishOnce sync.Once

	funcCreateChat          func(ctx context.Context, chat *model.ChatInfo) (i1 int64, err error)
	funcCreateChatOrigin    string
	inspectFuncCreateChat   func(ctx context.Context, chat *model.ChatInfo)
	afterCreateChatCounter  uint64
	beforeCreateChatCounter uint64
	CreateChatMock          mChatServiceIMockCreateChat

	funcCreateMessage          func(ctx context.Context, message *model.MessageInfo) (err error)
	funcCreateMessageOrigin    string
	inspectFuncCreateMessage   func(ctx context.Context, message *model.MessageInfo)
	afterCreateMessageCounter  uint64
	beforeCreateMessageCounter uint64
	CreateMessageMock          mChatServiceIMockCreateMessage

	funcCreateUser          func(ctx context.Context, info *model.UserInfo) (i1 int64, err error)
	funcCreateUserOrigin    string
	inspectFuncCreateUser   func(ctx context.Context, info *model.UserInfo)
	afterCreateUserCounter  uint64
	beforeCreateUserCounter uint64
	CreateUserMock          mChatServiceIMockCreateUser

	funcDeleteChat          func(ctx context.Context, id int64) (err error)
	funcDeleteChatOrigin    string
	inspectFuncDeleteChat   func(ctx context.Context, id int64)
	afterDeleteChatCounter  uint64
	beforeDeleteChatCounter uint64
	DeleteChatMock          mChatServiceIMockDeleteChat

	funcDeleteUser          func(ctx context.Context, id int64) (err error)
	funcDeleteUserOrigin    string
	inspectFuncDeleteUser   func(ctx context.Context, id int64)
	afterDeleteUserCounter  uint64
	beforeDeleteUserCounter uint64
	DeleteUserMock          mChatServiceIMockDeleteUser
}

// NewChatServiceIMock returns a mock for mm_service.ChatServiceI
func NewChatServiceIMock(t minimock.Tester) *ChatServiceIMock {
	m := &ChatServiceIMock{t: t}

	if controller, ok := t.(minimock.MockController); ok {
		controller.RegisterMocker(m)
	}

	m.CreateChatMock = mChatServiceIMockCreateChat{mock: m}
	m.CreateChatMock.callArgs = []*ChatServiceIMockCreateChatParams{}

	m.CreateMessageMock = mChatServiceIMockCreateMessage{mock: m}
	m.CreateMessageMock.callArgs = []*ChatServiceIMockCreateMessageParams{}

	m.CreateUserMock = mChatServiceIMockCreateUser{mock: m}
	m.CreateUserMock.callArgs = []*ChatServiceIMockCreateUserParams{}

	m.DeleteChatMock = mChatServiceIMockDeleteChat{mock: m}
	m.DeleteChatMock.callArgs = []*ChatServiceIMockDeleteChatParams{}

	m.DeleteUserMock = mChatServiceIMockDeleteUser{mock: m}
	m.DeleteUserMock.callArgs = []*ChatServiceIMockDeleteUserParams{}

	t.Cleanup(m.MinimockFinish)

	return m
}

type mChatServiceIMockCreateChat struct {
	optional           bool
	mock               *ChatServiceIMock
	defaultExpectation *ChatServiceIMockCreateChatExpectation
	expectations       []*ChatServiceIMockCreateChatExpectation

	callArgs []*ChatServiceIMockCreateChatParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// ChatServiceIMockCreateChatExpectation specifies expectation struct of the ChatServiceI.CreateChat
type ChatServiceIMockCreateChatExpectation struct {
	mock               *ChatServiceIMock
	params             *ChatServiceIMockCreateChatParams
	paramPtrs          *ChatServiceIMockCreateChatParamPtrs
	expectationOrigins ChatServiceIMockCreateChatExpectationOrigins
	results            *ChatServiceIMockCreateChatResults
	returnOrigin       string
	Counter            uint64
}

// ChatServiceIMockCreateChatParams contains parameters of the ChatServiceI.CreateChat
type ChatServiceIMockCreateChatParams struct {
	ctx  context.Context
	chat *model.ChatInfo
}

// ChatServiceIMockCreateChatParamPtrs contains pointers to parameters of the ChatServiceI.CreateChat
type ChatServiceIMockCreateChatParamPtrs struct {
	ctx  *context.Context
	chat **model.ChatInfo
}

// ChatServiceIMockCreateChatResults contains results of the ChatServiceI.CreateChat
type ChatServiceIMockCreateChatResults struct {
	i1  int64
	err error
}

// ChatServiceIMockCreateChatOrigins contains origins of expectations of the ChatServiceI.CreateChat
type ChatServiceIMockCreateChatExpectationOrigins struct {
	origin     string
	originCtx  string
	originChat string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmCreateChat *mChatServiceIMockCreateChat) Optional() *mChatServiceIMockCreateChat {
	mmCreateChat.optional = true
	return mmCreateChat
}

// Expect sets up expected params for ChatServiceI.CreateChat
func (mmCreateChat *mChatServiceIMockCreateChat) Expect(ctx context.Context, chat *model.ChatInfo) *mChatServiceIMockCreateChat {
	if mmCreateChat.mock.funcCreateChat != nil {
		mmCreateChat.mock.t.Fatalf("ChatServiceIMock.CreateChat mock is already set by Set")
	}

	if mmCreateChat.defaultExpectation == nil {
		mmCreateChat.defaultExpectation = &ChatServiceIMockCreateChatExpectation{}
	}

	if mmCreateChat.defaultExpectation.paramPtrs != nil {
		mmCreateChat.mock.t.Fatalf("ChatServiceIMock.CreateChat mock is already set by ExpectParams functions")
	}

	mmCreateChat.defaultExpectation.params = &ChatServiceIMockCreateChatParams{ctx, chat}
	mmCreateChat.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmCreateChat.expectations {
		if minimock.Equal(e.params, mmCreateChat.defaultExpectation.params) {
			mmCreateChat.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmCreateChat.defaultExpectation.params)
		}
	}

	return mmCreateChat
}

// ExpectCtxParam1 sets up expected param ctx for ChatServiceI.CreateChat
func (mmCreateChat *mChatServiceIMockCreateChat) ExpectCtxParam1(ctx context.Context) *mChatServiceIMockCreateChat {
	if mmCreateChat.mock.funcCreateChat != nil {
		mmCreateChat.mock.t.Fatalf("ChatServiceIMock.CreateChat mock is already set by Set")
	}

	if mmCreateChat.defaultExpectation == nil {
		mmCreateChat.defaultExpectation = &ChatServiceIMockCreateChatExpectation{}
	}

	if mmCreateChat.defaultExpectation.params != nil {
		mmCreateChat.mock.t.Fatalf("ChatServiceIMock.CreateChat mock is already set by Expect")
	}

	if mmCreateChat.defaultExpectation.paramPtrs == nil {
		mmCreateChat.defaultExpectation.paramPtrs = &ChatServiceIMockCreateChatParamPtrs{}
	}
	mmCreateChat.defaultExpectation.paramPtrs.ctx = &ctx
	mmCreateChat.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmCreateChat
}

// ExpectChatParam2 sets up expected param chat for ChatServiceI.CreateChat
func (mmCreateChat *mChatServiceIMockCreateChat) ExpectChatParam2(chat *model.ChatInfo) *mChatServiceIMockCreateChat {
	if mmCreateChat.mock.funcCreateChat != nil {
		mmCreateChat.mock.t.Fatalf("ChatServiceIMock.CreateChat mock is already set by Set")
	}

	if mmCreateChat.defaultExpectation == nil {
		mmCreateChat.defaultExpectation = &ChatServiceIMockCreateChatExpectation{}
	}

	if mmCreateChat.defaultExpectation.params != nil {
		mmCreateChat.mock.t.Fatalf("ChatServiceIMock.CreateChat mock is already set by Expect")
	}

	if mmCreateChat.defaultExpectation.paramPtrs == nil {
		mmCreateChat.defaultExpectation.paramPtrs = &ChatServiceIMockCreateChatParamPtrs{}
	}
	mmCreateChat.defaultExpectation.paramPtrs.chat = &chat
	mmCreateChat.defaultExpectation.expectationOrigins.originChat = minimock.CallerInfo(1)

	return mmCreateChat
}

// Inspect accepts an inspector function that has same arguments as the ChatServiceI.CreateChat
func (mmCreateChat *mChatServiceIMockCreateChat) Inspect(f func(ctx context.Context, chat *model.ChatInfo)) *mChatServiceIMockCreateChat {
	if mmCreateChat.mock.inspectFuncCreateChat != nil {
		mmCreateChat.mock.t.Fatalf("Inspect function is already set for ChatServiceIMock.CreateChat")
	}

	mmCreateChat.mock.inspectFuncCreateChat = f

	return mmCreateChat
}

// Return sets up results that will be returned by ChatServiceI.CreateChat
func (mmCreateChat *mChatServiceIMockCreateChat) Return(i1 int64, err error) *ChatServiceIMock {
	if mmCreateChat.mock.funcCreateChat != nil {
		mmCreateChat.mock.t.Fatalf("ChatServiceIMock.CreateChat mock is already set by Set")
	}

	if mmCreateChat.defaultExpectation == nil {
		mmCreateChat.defaultExpectation = &ChatServiceIMockCreateChatExpectation{mock: mmCreateChat.mock}
	}
	mmCreateChat.defaultExpectation.results = &ChatServiceIMockCreateChatResults{i1, err}
	mmCreateChat.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmCreateChat.mock
}

// Set uses given function f to mock the ChatServiceI.CreateChat method
func (mmCreateChat *mChatServiceIMockCreateChat) Set(f func(ctx context.Context, chat *model.ChatInfo) (i1 int64, err error)) *ChatServiceIMock {
	if mmCreateChat.defaultExpectation != nil {
		mmCreateChat.mock.t.Fatalf("Default expectation is already set for the ChatServiceI.CreateChat method")
	}

	if len(mmCreateChat.expectations) > 0 {
		mmCreateChat.mock.t.Fatalf("Some expectations are already set for the ChatServiceI.CreateChat method")
	}

	mmCreateChat.mock.funcCreateChat = f
	mmCreateChat.mock.funcCreateChatOrigin = minimock.CallerInfo(1)
	return mmCreateChat.mock
}

// When sets expectation for the ChatServiceI.CreateChat which will trigger the result defined by the following
// Then helper
func (mmCreateChat *mChatServiceIMockCreateChat) When(ctx context.Context, chat *model.ChatInfo) *ChatServiceIMockCreateChatExpectation {
	if mmCreateChat.mock.funcCreateChat != nil {
		mmCreateChat.mock.t.Fatalf("ChatServiceIMock.CreateChat mock is already set by Set")
	}

	expectation := &ChatServiceIMockCreateChatExpectation{
		mock:               mmCreateChat.mock,
		params:             &ChatServiceIMockCreateChatParams{ctx, chat},
		expectationOrigins: ChatServiceIMockCreateChatExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmCreateChat.expectations = append(mmCreateChat.expectations, expectation)
	return expectation
}

// Then sets up ChatServiceI.CreateChat return parameters for the expectation previously defined by the When method
func (e *ChatServiceIMockCreateChatExpectation) Then(i1 int64, err error) *ChatServiceIMock {
	e.results = &ChatServiceIMockCreateChatResults{i1, err}
	return e.mock
}

// Times sets number of times ChatServiceI.CreateChat should be invoked
func (mmCreateChat *mChatServiceIMockCreateChat) Times(n uint64) *mChatServiceIMockCreateChat {
	if n == 0 {
		mmCreateChat.mock.t.Fatalf("Times of ChatServiceIMock.CreateChat mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmCreateChat.expectedInvocations, n)
	mmCreateChat.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmCreateChat
}

func (mmCreateChat *mChatServiceIMockCreateChat) invocationsDone() bool {
	if len(mmCreateChat.expectations) == 0 && mmCreateChat.defaultExpectation == nil && mmCreateChat.mock.funcCreateChat == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmCreateChat.mock.afterCreateChatCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmCreateChat.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// CreateChat implements mm_service.ChatServiceI
func (mmCreateChat *ChatServiceIMock) CreateChat(ctx context.Context, chat *model.ChatInfo) (i1 int64, err error) {
	mm_atomic.AddUint64(&mmCreateChat.beforeCreateChatCounter, 1)
	defer mm_atomic.AddUint64(&mmCreateChat.afterCreateChatCounter, 1)

	mmCreateChat.t.Helper()

	if mmCreateChat.inspectFuncCreateChat != nil {
		mmCreateChat.inspectFuncCreateChat(ctx, chat)
	}

	mm_params := ChatServiceIMockCreateChatParams{ctx, chat}

	// Record call args
	mmCreateChat.CreateChatMock.mutex.Lock()
	mmCreateChat.CreateChatMock.callArgs = append(mmCreateChat.CreateChatMock.callArgs, &mm_params)
	mmCreateChat.CreateChatMock.mutex.Unlock()

	for _, e := range mmCreateChat.CreateChatMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.i1, e.results.err
		}
	}

	if mmCreateChat.CreateChatMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmCreateChat.CreateChatMock.defaultExpectation.Counter, 1)
		mm_want := mmCreateChat.CreateChatMock.defaultExpectation.params
		mm_want_ptrs := mmCreateChat.CreateChatMock.defaultExpectation.paramPtrs

		mm_got := ChatServiceIMockCreateChatParams{ctx, chat}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmCreateChat.t.Errorf("ChatServiceIMock.CreateChat got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmCreateChat.CreateChatMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.chat != nil && !minimock.Equal(*mm_want_ptrs.chat, mm_got.chat) {
				mmCreateChat.t.Errorf("ChatServiceIMock.CreateChat got unexpected parameter chat, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmCreateChat.CreateChatMock.defaultExpectation.expectationOrigins.originChat, *mm_want_ptrs.chat, mm_got.chat, minimock.Diff(*mm_want_ptrs.chat, mm_got.chat))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmCreateChat.t.Errorf("ChatServiceIMock.CreateChat got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmCreateChat.CreateChatMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmCreateChat.CreateChatMock.defaultExpectation.results
		if mm_results == nil {
			mmCreateChat.t.Fatal("No results are set for the ChatServiceIMock.CreateChat")
		}
		return (*mm_results).i1, (*mm_results).err
	}
	if mmCreateChat.funcCreateChat != nil {
		return mmCreateChat.funcCreateChat(ctx, chat)
	}
	mmCreateChat.t.Fatalf("Unexpected call to ChatServiceIMock.CreateChat. %v %v", ctx, chat)
	return
}

// CreateChatAfterCounter returns a count of finished ChatServiceIMock.CreateChat invocations
func (mmCreateChat *ChatServiceIMock) CreateChatAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmCreateChat.afterCreateChatCounter)
}

// CreateChatBeforeCounter returns a count of ChatServiceIMock.CreateChat invocations
func (mmCreateChat *ChatServiceIMock) CreateChatBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmCreateChat.beforeCreateChatCounter)
}

// Calls returns a list of arguments used in each call to ChatServiceIMock.CreateChat.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmCreateChat *mChatServiceIMockCreateChat) Calls() []*ChatServiceIMockCreateChatParams {
	mmCreateChat.mutex.RLock()

	argCopy := make([]*ChatServiceIMockCreateChatParams, len(mmCreateChat.callArgs))
	copy(argCopy, mmCreateChat.callArgs)

	mmCreateChat.mutex.RUnlock()

	return argCopy
}

// MinimockCreateChatDone returns true if the count of the CreateChat invocations corresponds
// the number of defined expectations
func (m *ChatServiceIMock) MinimockCreateChatDone() bool {
	if m.CreateChatMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.CreateChatMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.CreateChatMock.invocationsDone()
}

// MinimockCreateChatInspect logs each unmet expectation
func (m *ChatServiceIMock) MinimockCreateChatInspect() {
	for _, e := range m.CreateChatMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to ChatServiceIMock.CreateChat at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterCreateChatCounter := mm_atomic.LoadUint64(&m.afterCreateChatCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.CreateChatMock.defaultExpectation != nil && afterCreateChatCounter < 1 {
		if m.CreateChatMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to ChatServiceIMock.CreateChat at\n%s", m.CreateChatMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to ChatServiceIMock.CreateChat at\n%s with params: %#v", m.CreateChatMock.defaultExpectation.expectationOrigins.origin, *m.CreateChatMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcCreateChat != nil && afterCreateChatCounter < 1 {
		m.t.Errorf("Expected call to ChatServiceIMock.CreateChat at\n%s", m.funcCreateChatOrigin)
	}

	if !m.CreateChatMock.invocationsDone() && afterCreateChatCounter > 0 {
		m.t.Errorf("Expected %d calls to ChatServiceIMock.CreateChat at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.CreateChatMock.expectedInvocations), m.CreateChatMock.expectedInvocationsOrigin, afterCreateChatCounter)
	}
}

type mChatServiceIMockCreateMessage struct {
	optional           bool
	mock               *ChatServiceIMock
	defaultExpectation *ChatServiceIMockCreateMessageExpectation
	expectations       []*ChatServiceIMockCreateMessageExpectation

	callArgs []*ChatServiceIMockCreateMessageParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// ChatServiceIMockCreateMessageExpectation specifies expectation struct of the ChatServiceI.CreateMessage
type ChatServiceIMockCreateMessageExpectation struct {
	mock               *ChatServiceIMock
	params             *ChatServiceIMockCreateMessageParams
	paramPtrs          *ChatServiceIMockCreateMessageParamPtrs
	expectationOrigins ChatServiceIMockCreateMessageExpectationOrigins
	results            *ChatServiceIMockCreateMessageResults
	returnOrigin       string
	Counter            uint64
}

// ChatServiceIMockCreateMessageParams contains parameters of the ChatServiceI.CreateMessage
type ChatServiceIMockCreateMessageParams struct {
	ctx     context.Context
	message *model.MessageInfo
}

// ChatServiceIMockCreateMessageParamPtrs contains pointers to parameters of the ChatServiceI.CreateMessage
type ChatServiceIMockCreateMessageParamPtrs struct {
	ctx     *context.Context
	message **model.MessageInfo
}

// ChatServiceIMockCreateMessageResults contains results of the ChatServiceI.CreateMessage
type ChatServiceIMockCreateMessageResults struct {
	err error
}

// ChatServiceIMockCreateMessageOrigins contains origins of expectations of the ChatServiceI.CreateMessage
type ChatServiceIMockCreateMessageExpectationOrigins struct {
	origin        string
	originCtx     string
	originMessage string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmCreateMessage *mChatServiceIMockCreateMessage) Optional() *mChatServiceIMockCreateMessage {
	mmCreateMessage.optional = true
	return mmCreateMessage
}

// Expect sets up expected params for ChatServiceI.CreateMessage
func (mmCreateMessage *mChatServiceIMockCreateMessage) Expect(ctx context.Context, message *model.MessageInfo) *mChatServiceIMockCreateMessage {
	if mmCreateMessage.mock.funcCreateMessage != nil {
		mmCreateMessage.mock.t.Fatalf("ChatServiceIMock.CreateMessage mock is already set by Set")
	}

	if mmCreateMessage.defaultExpectation == nil {
		mmCreateMessage.defaultExpectation = &ChatServiceIMockCreateMessageExpectation{}
	}

	if mmCreateMessage.defaultExpectation.paramPtrs != nil {
		mmCreateMessage.mock.t.Fatalf("ChatServiceIMock.CreateMessage mock is already set by ExpectParams functions")
	}

	mmCreateMessage.defaultExpectation.params = &ChatServiceIMockCreateMessageParams{ctx, message}
	mmCreateMessage.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmCreateMessage.expectations {
		if minimock.Equal(e.params, mmCreateMessage.defaultExpectation.params) {
			mmCreateMessage.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmCreateMessage.defaultExpectation.params)
		}
	}

	return mmCreateMessage
}

// ExpectCtxParam1 sets up expected param ctx for ChatServiceI.CreateMessage
func (mmCreateMessage *mChatServiceIMockCreateMessage) ExpectCtxParam1(ctx context.Context) *mChatServiceIMockCreateMessage {
	if mmCreateMessage.mock.funcCreateMessage != nil {
		mmCreateMessage.mock.t.Fatalf("ChatServiceIMock.CreateMessage mock is already set by Set")
	}

	if mmCreateMessage.defaultExpectation == nil {
		mmCreateMessage.defaultExpectation = &ChatServiceIMockCreateMessageExpectation{}
	}

	if mmCreateMessage.defaultExpectation.params != nil {
		mmCreateMessage.mock.t.Fatalf("ChatServiceIMock.CreateMessage mock is already set by Expect")
	}

	if mmCreateMessage.defaultExpectation.paramPtrs == nil {
		mmCreateMessage.defaultExpectation.paramPtrs = &ChatServiceIMockCreateMessageParamPtrs{}
	}
	mmCreateMessage.defaultExpectation.paramPtrs.ctx = &ctx
	mmCreateMessage.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmCreateMessage
}

// ExpectMessageParam2 sets up expected param message for ChatServiceI.CreateMessage
func (mmCreateMessage *mChatServiceIMockCreateMessage) ExpectMessageParam2(message *model.MessageInfo) *mChatServiceIMockCreateMessage {
	if mmCreateMessage.mock.funcCreateMessage != nil {
		mmCreateMessage.mock.t.Fatalf("ChatServiceIMock.CreateMessage mock is already set by Set")
	}

	if mmCreateMessage.defaultExpectation == nil {
		mmCreateMessage.defaultExpectation = &ChatServiceIMockCreateMessageExpectation{}
	}

	if mmCreateMessage.defaultExpectation.params != nil {
		mmCreateMessage.mock.t.Fatalf("ChatServiceIMock.CreateMessage mock is already set by Expect")
	}

	if mmCreateMessage.defaultExpectation.paramPtrs == nil {
		mmCreateMessage.defaultExpectation.paramPtrs = &ChatServiceIMockCreateMessageParamPtrs{}
	}
	mmCreateMessage.defaultExpectation.paramPtrs.message = &message
	mmCreateMessage.defaultExpectation.expectationOrigins.originMessage = minimock.CallerInfo(1)

	return mmCreateMessage
}

// Inspect accepts an inspector function that has same arguments as the ChatServiceI.CreateMessage
func (mmCreateMessage *mChatServiceIMockCreateMessage) Inspect(f func(ctx context.Context, message *model.MessageInfo)) *mChatServiceIMockCreateMessage {
	if mmCreateMessage.mock.inspectFuncCreateMessage != nil {
		mmCreateMessage.mock.t.Fatalf("Inspect function is already set for ChatServiceIMock.CreateMessage")
	}

	mmCreateMessage.mock.inspectFuncCreateMessage = f

	return mmCreateMessage
}

// Return sets up results that will be returned by ChatServiceI.CreateMessage
func (mmCreateMessage *mChatServiceIMockCreateMessage) Return(err error) *ChatServiceIMock {
	if mmCreateMessage.mock.funcCreateMessage != nil {
		mmCreateMessage.mock.t.Fatalf("ChatServiceIMock.CreateMessage mock is already set by Set")
	}

	if mmCreateMessage.defaultExpectation == nil {
		mmCreateMessage.defaultExpectation = &ChatServiceIMockCreateMessageExpectation{mock: mmCreateMessage.mock}
	}
	mmCreateMessage.defaultExpectation.results = &ChatServiceIMockCreateMessageResults{err}
	mmCreateMessage.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmCreateMessage.mock
}

// Set uses given function f to mock the ChatServiceI.CreateMessage method
func (mmCreateMessage *mChatServiceIMockCreateMessage) Set(f func(ctx context.Context, message *model.MessageInfo) (err error)) *ChatServiceIMock {
	if mmCreateMessage.defaultExpectation != nil {
		mmCreateMessage.mock.t.Fatalf("Default expectation is already set for the ChatServiceI.CreateMessage method")
	}

	if len(mmCreateMessage.expectations) > 0 {
		mmCreateMessage.mock.t.Fatalf("Some expectations are already set for the ChatServiceI.CreateMessage method")
	}

	mmCreateMessage.mock.funcCreateMessage = f
	mmCreateMessage.mock.funcCreateMessageOrigin = minimock.CallerInfo(1)
	return mmCreateMessage.mock
}

// When sets expectation for the ChatServiceI.CreateMessage which will trigger the result defined by the following
// Then helper
func (mmCreateMessage *mChatServiceIMockCreateMessage) When(ctx context.Context, message *model.MessageInfo) *ChatServiceIMockCreateMessageExpectation {
	if mmCreateMessage.mock.funcCreateMessage != nil {
		mmCreateMessage.mock.t.Fatalf("ChatServiceIMock.CreateMessage mock is already set by Set")
	}

	expectation := &ChatServiceIMockCreateMessageExpectation{
		mock:               mmCreateMessage.mock,
		params:             &ChatServiceIMockCreateMessageParams{ctx, message},
		expectationOrigins: ChatServiceIMockCreateMessageExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmCreateMessage.expectations = append(mmCreateMessage.expectations, expectation)
	return expectation
}

// Then sets up ChatServiceI.CreateMessage return parameters for the expectation previously defined by the When method
func (e *ChatServiceIMockCreateMessageExpectation) Then(err error) *ChatServiceIMock {
	e.results = &ChatServiceIMockCreateMessageResults{err}
	return e.mock
}

// Times sets number of times ChatServiceI.CreateMessage should be invoked
func (mmCreateMessage *mChatServiceIMockCreateMessage) Times(n uint64) *mChatServiceIMockCreateMessage {
	if n == 0 {
		mmCreateMessage.mock.t.Fatalf("Times of ChatServiceIMock.CreateMessage mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmCreateMessage.expectedInvocations, n)
	mmCreateMessage.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmCreateMessage
}

func (mmCreateMessage *mChatServiceIMockCreateMessage) invocationsDone() bool {
	if len(mmCreateMessage.expectations) == 0 && mmCreateMessage.defaultExpectation == nil && mmCreateMessage.mock.funcCreateMessage == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmCreateMessage.mock.afterCreateMessageCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmCreateMessage.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// CreateMessage implements mm_service.ChatServiceI
func (mmCreateMessage *ChatServiceIMock) CreateMessage(ctx context.Context, message *model.MessageInfo) (err error) {
	mm_atomic.AddUint64(&mmCreateMessage.beforeCreateMessageCounter, 1)
	defer mm_atomic.AddUint64(&mmCreateMessage.afterCreateMessageCounter, 1)

	mmCreateMessage.t.Helper()

	if mmCreateMessage.inspectFuncCreateMessage != nil {
		mmCreateMessage.inspectFuncCreateMessage(ctx, message)
	}

	mm_params := ChatServiceIMockCreateMessageParams{ctx, message}

	// Record call args
	mmCreateMessage.CreateMessageMock.mutex.Lock()
	mmCreateMessage.CreateMessageMock.callArgs = append(mmCreateMessage.CreateMessageMock.callArgs, &mm_params)
	mmCreateMessage.CreateMessageMock.mutex.Unlock()

	for _, e := range mmCreateMessage.CreateMessageMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmCreateMessage.CreateMessageMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmCreateMessage.CreateMessageMock.defaultExpectation.Counter, 1)
		mm_want := mmCreateMessage.CreateMessageMock.defaultExpectation.params
		mm_want_ptrs := mmCreateMessage.CreateMessageMock.defaultExpectation.paramPtrs

		mm_got := ChatServiceIMockCreateMessageParams{ctx, message}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmCreateMessage.t.Errorf("ChatServiceIMock.CreateMessage got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmCreateMessage.CreateMessageMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.message != nil && !minimock.Equal(*mm_want_ptrs.message, mm_got.message) {
				mmCreateMessage.t.Errorf("ChatServiceIMock.CreateMessage got unexpected parameter message, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmCreateMessage.CreateMessageMock.defaultExpectation.expectationOrigins.originMessage, *mm_want_ptrs.message, mm_got.message, minimock.Diff(*mm_want_ptrs.message, mm_got.message))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmCreateMessage.t.Errorf("ChatServiceIMock.CreateMessage got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmCreateMessage.CreateMessageMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmCreateMessage.CreateMessageMock.defaultExpectation.results
		if mm_results == nil {
			mmCreateMessage.t.Fatal("No results are set for the ChatServiceIMock.CreateMessage")
		}
		return (*mm_results).err
	}
	if mmCreateMessage.funcCreateMessage != nil {
		return mmCreateMessage.funcCreateMessage(ctx, message)
	}
	mmCreateMessage.t.Fatalf("Unexpected call to ChatServiceIMock.CreateMessage. %v %v", ctx, message)
	return
}

// CreateMessageAfterCounter returns a count of finished ChatServiceIMock.CreateMessage invocations
func (mmCreateMessage *ChatServiceIMock) CreateMessageAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmCreateMessage.afterCreateMessageCounter)
}

// CreateMessageBeforeCounter returns a count of ChatServiceIMock.CreateMessage invocations
func (mmCreateMessage *ChatServiceIMock) CreateMessageBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmCreateMessage.beforeCreateMessageCounter)
}

// Calls returns a list of arguments used in each call to ChatServiceIMock.CreateMessage.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmCreateMessage *mChatServiceIMockCreateMessage) Calls() []*ChatServiceIMockCreateMessageParams {
	mmCreateMessage.mutex.RLock()

	argCopy := make([]*ChatServiceIMockCreateMessageParams, len(mmCreateMessage.callArgs))
	copy(argCopy, mmCreateMessage.callArgs)

	mmCreateMessage.mutex.RUnlock()

	return argCopy
}

// MinimockCreateMessageDone returns true if the count of the CreateMessage invocations corresponds
// the number of defined expectations
func (m *ChatServiceIMock) MinimockCreateMessageDone() bool {
	if m.CreateMessageMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.CreateMessageMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.CreateMessageMock.invocationsDone()
}

// MinimockCreateMessageInspect logs each unmet expectation
func (m *ChatServiceIMock) MinimockCreateMessageInspect() {
	for _, e := range m.CreateMessageMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to ChatServiceIMock.CreateMessage at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterCreateMessageCounter := mm_atomic.LoadUint64(&m.afterCreateMessageCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.CreateMessageMock.defaultExpectation != nil && afterCreateMessageCounter < 1 {
		if m.CreateMessageMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to ChatServiceIMock.CreateMessage at\n%s", m.CreateMessageMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to ChatServiceIMock.CreateMessage at\n%s with params: %#v", m.CreateMessageMock.defaultExpectation.expectationOrigins.origin, *m.CreateMessageMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcCreateMessage != nil && afterCreateMessageCounter < 1 {
		m.t.Errorf("Expected call to ChatServiceIMock.CreateMessage at\n%s", m.funcCreateMessageOrigin)
	}

	if !m.CreateMessageMock.invocationsDone() && afterCreateMessageCounter > 0 {
		m.t.Errorf("Expected %d calls to ChatServiceIMock.CreateMessage at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.CreateMessageMock.expectedInvocations), m.CreateMessageMock.expectedInvocationsOrigin, afterCreateMessageCounter)
	}
}

type mChatServiceIMockCreateUser struct {
	optional           bool
	mock               *ChatServiceIMock
	defaultExpectation *ChatServiceIMockCreateUserExpectation
	expectations       []*ChatServiceIMockCreateUserExpectation

	callArgs []*ChatServiceIMockCreateUserParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// ChatServiceIMockCreateUserExpectation specifies expectation struct of the ChatServiceI.CreateUser
type ChatServiceIMockCreateUserExpectation struct {
	mock               *ChatServiceIMock
	params             *ChatServiceIMockCreateUserParams
	paramPtrs          *ChatServiceIMockCreateUserParamPtrs
	expectationOrigins ChatServiceIMockCreateUserExpectationOrigins
	results            *ChatServiceIMockCreateUserResults
	returnOrigin       string
	Counter            uint64
}

// ChatServiceIMockCreateUserParams contains parameters of the ChatServiceI.CreateUser
type ChatServiceIMockCreateUserParams struct {
	ctx  context.Context
	info *model.UserInfo
}

// ChatServiceIMockCreateUserParamPtrs contains pointers to parameters of the ChatServiceI.CreateUser
type ChatServiceIMockCreateUserParamPtrs struct {
	ctx  *context.Context
	info **model.UserInfo
}

// ChatServiceIMockCreateUserResults contains results of the ChatServiceI.CreateUser
type ChatServiceIMockCreateUserResults struct {
	i1  int64
	err error
}

// ChatServiceIMockCreateUserOrigins contains origins of expectations of the ChatServiceI.CreateUser
type ChatServiceIMockCreateUserExpectationOrigins struct {
	origin     string
	originCtx  string
	originInfo string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmCreateUser *mChatServiceIMockCreateUser) Optional() *mChatServiceIMockCreateUser {
	mmCreateUser.optional = true
	return mmCreateUser
}

// Expect sets up expected params for ChatServiceI.CreateUser
func (mmCreateUser *mChatServiceIMockCreateUser) Expect(ctx context.Context, info *model.UserInfo) *mChatServiceIMockCreateUser {
	if mmCreateUser.mock.funcCreateUser != nil {
		mmCreateUser.mock.t.Fatalf("ChatServiceIMock.CreateUser mock is already set by Set")
	}

	if mmCreateUser.defaultExpectation == nil {
		mmCreateUser.defaultExpectation = &ChatServiceIMockCreateUserExpectation{}
	}

	if mmCreateUser.defaultExpectation.paramPtrs != nil {
		mmCreateUser.mock.t.Fatalf("ChatServiceIMock.CreateUser mock is already set by ExpectParams functions")
	}

	mmCreateUser.defaultExpectation.params = &ChatServiceIMockCreateUserParams{ctx, info}
	mmCreateUser.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmCreateUser.expectations {
		if minimock.Equal(e.params, mmCreateUser.defaultExpectation.params) {
			mmCreateUser.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmCreateUser.defaultExpectation.params)
		}
	}

	return mmCreateUser
}

// ExpectCtxParam1 sets up expected param ctx for ChatServiceI.CreateUser
func (mmCreateUser *mChatServiceIMockCreateUser) ExpectCtxParam1(ctx context.Context) *mChatServiceIMockCreateUser {
	if mmCreateUser.mock.funcCreateUser != nil {
		mmCreateUser.mock.t.Fatalf("ChatServiceIMock.CreateUser mock is already set by Set")
	}

	if mmCreateUser.defaultExpectation == nil {
		mmCreateUser.defaultExpectation = &ChatServiceIMockCreateUserExpectation{}
	}

	if mmCreateUser.defaultExpectation.params != nil {
		mmCreateUser.mock.t.Fatalf("ChatServiceIMock.CreateUser mock is already set by Expect")
	}

	if mmCreateUser.defaultExpectation.paramPtrs == nil {
		mmCreateUser.defaultExpectation.paramPtrs = &ChatServiceIMockCreateUserParamPtrs{}
	}
	mmCreateUser.defaultExpectation.paramPtrs.ctx = &ctx
	mmCreateUser.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmCreateUser
}

// ExpectInfoParam2 sets up expected param info for ChatServiceI.CreateUser
func (mmCreateUser *mChatServiceIMockCreateUser) ExpectInfoParam2(info *model.UserInfo) *mChatServiceIMockCreateUser {
	if mmCreateUser.mock.funcCreateUser != nil {
		mmCreateUser.mock.t.Fatalf("ChatServiceIMock.CreateUser mock is already set by Set")
	}

	if mmCreateUser.defaultExpectation == nil {
		mmCreateUser.defaultExpectation = &ChatServiceIMockCreateUserExpectation{}
	}

	if mmCreateUser.defaultExpectation.params != nil {
		mmCreateUser.mock.t.Fatalf("ChatServiceIMock.CreateUser mock is already set by Expect")
	}

	if mmCreateUser.defaultExpectation.paramPtrs == nil {
		mmCreateUser.defaultExpectation.paramPtrs = &ChatServiceIMockCreateUserParamPtrs{}
	}
	mmCreateUser.defaultExpectation.paramPtrs.info = &info
	mmCreateUser.defaultExpectation.expectationOrigins.originInfo = minimock.CallerInfo(1)

	return mmCreateUser
}

// Inspect accepts an inspector function that has same arguments as the ChatServiceI.CreateUser
func (mmCreateUser *mChatServiceIMockCreateUser) Inspect(f func(ctx context.Context, info *model.UserInfo)) *mChatServiceIMockCreateUser {
	if mmCreateUser.mock.inspectFuncCreateUser != nil {
		mmCreateUser.mock.t.Fatalf("Inspect function is already set for ChatServiceIMock.CreateUser")
	}

	mmCreateUser.mock.inspectFuncCreateUser = f

	return mmCreateUser
}

// Return sets up results that will be returned by ChatServiceI.CreateUser
func (mmCreateUser *mChatServiceIMockCreateUser) Return(i1 int64, err error) *ChatServiceIMock {
	if mmCreateUser.mock.funcCreateUser != nil {
		mmCreateUser.mock.t.Fatalf("ChatServiceIMock.CreateUser mock is already set by Set")
	}

	if mmCreateUser.defaultExpectation == nil {
		mmCreateUser.defaultExpectation = &ChatServiceIMockCreateUserExpectation{mock: mmCreateUser.mock}
	}
	mmCreateUser.defaultExpectation.results = &ChatServiceIMockCreateUserResults{i1, err}
	mmCreateUser.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmCreateUser.mock
}

// Set uses given function f to mock the ChatServiceI.CreateUser method
func (mmCreateUser *mChatServiceIMockCreateUser) Set(f func(ctx context.Context, info *model.UserInfo) (i1 int64, err error)) *ChatServiceIMock {
	if mmCreateUser.defaultExpectation != nil {
		mmCreateUser.mock.t.Fatalf("Default expectation is already set for the ChatServiceI.CreateUser method")
	}

	if len(mmCreateUser.expectations) > 0 {
		mmCreateUser.mock.t.Fatalf("Some expectations are already set for the ChatServiceI.CreateUser method")
	}

	mmCreateUser.mock.funcCreateUser = f
	mmCreateUser.mock.funcCreateUserOrigin = minimock.CallerInfo(1)
	return mmCreateUser.mock
}

// When sets expectation for the ChatServiceI.CreateUser which will trigger the result defined by the following
// Then helper
func (mmCreateUser *mChatServiceIMockCreateUser) When(ctx context.Context, info *model.UserInfo) *ChatServiceIMockCreateUserExpectation {
	if mmCreateUser.mock.funcCreateUser != nil {
		mmCreateUser.mock.t.Fatalf("ChatServiceIMock.CreateUser mock is already set by Set")
	}

	expectation := &ChatServiceIMockCreateUserExpectation{
		mock:               mmCreateUser.mock,
		params:             &ChatServiceIMockCreateUserParams{ctx, info},
		expectationOrigins: ChatServiceIMockCreateUserExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmCreateUser.expectations = append(mmCreateUser.expectations, expectation)
	return expectation
}

// Then sets up ChatServiceI.CreateUser return parameters for the expectation previously defined by the When method
func (e *ChatServiceIMockCreateUserExpectation) Then(i1 int64, err error) *ChatServiceIMock {
	e.results = &ChatServiceIMockCreateUserResults{i1, err}
	return e.mock
}

// Times sets number of times ChatServiceI.CreateUser should be invoked
func (mmCreateUser *mChatServiceIMockCreateUser) Times(n uint64) *mChatServiceIMockCreateUser {
	if n == 0 {
		mmCreateUser.mock.t.Fatalf("Times of ChatServiceIMock.CreateUser mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmCreateUser.expectedInvocations, n)
	mmCreateUser.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmCreateUser
}

func (mmCreateUser *mChatServiceIMockCreateUser) invocationsDone() bool {
	if len(mmCreateUser.expectations) == 0 && mmCreateUser.defaultExpectation == nil && mmCreateUser.mock.funcCreateUser == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmCreateUser.mock.afterCreateUserCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmCreateUser.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// CreateUser implements mm_service.ChatServiceI
func (mmCreateUser *ChatServiceIMock) CreateUser(ctx context.Context, info *model.UserInfo) (i1 int64, err error) {
	mm_atomic.AddUint64(&mmCreateUser.beforeCreateUserCounter, 1)
	defer mm_atomic.AddUint64(&mmCreateUser.afterCreateUserCounter, 1)

	mmCreateUser.t.Helper()

	if mmCreateUser.inspectFuncCreateUser != nil {
		mmCreateUser.inspectFuncCreateUser(ctx, info)
	}

	mm_params := ChatServiceIMockCreateUserParams{ctx, info}

	// Record call args
	mmCreateUser.CreateUserMock.mutex.Lock()
	mmCreateUser.CreateUserMock.callArgs = append(mmCreateUser.CreateUserMock.callArgs, &mm_params)
	mmCreateUser.CreateUserMock.mutex.Unlock()

	for _, e := range mmCreateUser.CreateUserMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.i1, e.results.err
		}
	}

	if mmCreateUser.CreateUserMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmCreateUser.CreateUserMock.defaultExpectation.Counter, 1)
		mm_want := mmCreateUser.CreateUserMock.defaultExpectation.params
		mm_want_ptrs := mmCreateUser.CreateUserMock.defaultExpectation.paramPtrs

		mm_got := ChatServiceIMockCreateUserParams{ctx, info}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmCreateUser.t.Errorf("ChatServiceIMock.CreateUser got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmCreateUser.CreateUserMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.info != nil && !minimock.Equal(*mm_want_ptrs.info, mm_got.info) {
				mmCreateUser.t.Errorf("ChatServiceIMock.CreateUser got unexpected parameter info, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmCreateUser.CreateUserMock.defaultExpectation.expectationOrigins.originInfo, *mm_want_ptrs.info, mm_got.info, minimock.Diff(*mm_want_ptrs.info, mm_got.info))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmCreateUser.t.Errorf("ChatServiceIMock.CreateUser got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmCreateUser.CreateUserMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmCreateUser.CreateUserMock.defaultExpectation.results
		if mm_results == nil {
			mmCreateUser.t.Fatal("No results are set for the ChatServiceIMock.CreateUser")
		}
		return (*mm_results).i1, (*mm_results).err
	}
	if mmCreateUser.funcCreateUser != nil {
		return mmCreateUser.funcCreateUser(ctx, info)
	}
	mmCreateUser.t.Fatalf("Unexpected call to ChatServiceIMock.CreateUser. %v %v", ctx, info)
	return
}

// CreateUserAfterCounter returns a count of finished ChatServiceIMock.CreateUser invocations
func (mmCreateUser *ChatServiceIMock) CreateUserAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmCreateUser.afterCreateUserCounter)
}

// CreateUserBeforeCounter returns a count of ChatServiceIMock.CreateUser invocations
func (mmCreateUser *ChatServiceIMock) CreateUserBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmCreateUser.beforeCreateUserCounter)
}

// Calls returns a list of arguments used in each call to ChatServiceIMock.CreateUser.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmCreateUser *mChatServiceIMockCreateUser) Calls() []*ChatServiceIMockCreateUserParams {
	mmCreateUser.mutex.RLock()

	argCopy := make([]*ChatServiceIMockCreateUserParams, len(mmCreateUser.callArgs))
	copy(argCopy, mmCreateUser.callArgs)

	mmCreateUser.mutex.RUnlock()

	return argCopy
}

// MinimockCreateUserDone returns true if the count of the CreateUser invocations corresponds
// the number of defined expectations
func (m *ChatServiceIMock) MinimockCreateUserDone() bool {
	if m.CreateUserMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.CreateUserMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.CreateUserMock.invocationsDone()
}

// MinimockCreateUserInspect logs each unmet expectation
func (m *ChatServiceIMock) MinimockCreateUserInspect() {
	for _, e := range m.CreateUserMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to ChatServiceIMock.CreateUser at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterCreateUserCounter := mm_atomic.LoadUint64(&m.afterCreateUserCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.CreateUserMock.defaultExpectation != nil && afterCreateUserCounter < 1 {
		if m.CreateUserMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to ChatServiceIMock.CreateUser at\n%s", m.CreateUserMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to ChatServiceIMock.CreateUser at\n%s with params: %#v", m.CreateUserMock.defaultExpectation.expectationOrigins.origin, *m.CreateUserMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcCreateUser != nil && afterCreateUserCounter < 1 {
		m.t.Errorf("Expected call to ChatServiceIMock.CreateUser at\n%s", m.funcCreateUserOrigin)
	}

	if !m.CreateUserMock.invocationsDone() && afterCreateUserCounter > 0 {
		m.t.Errorf("Expected %d calls to ChatServiceIMock.CreateUser at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.CreateUserMock.expectedInvocations), m.CreateUserMock.expectedInvocationsOrigin, afterCreateUserCounter)
	}
}

type mChatServiceIMockDeleteChat struct {
	optional           bool
	mock               *ChatServiceIMock
	defaultExpectation *ChatServiceIMockDeleteChatExpectation
	expectations       []*ChatServiceIMockDeleteChatExpectation

	callArgs []*ChatServiceIMockDeleteChatParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// ChatServiceIMockDeleteChatExpectation specifies expectation struct of the ChatServiceI.DeleteChat
type ChatServiceIMockDeleteChatExpectation struct {
	mock               *ChatServiceIMock
	params             *ChatServiceIMockDeleteChatParams
	paramPtrs          *ChatServiceIMockDeleteChatParamPtrs
	expectationOrigins ChatServiceIMockDeleteChatExpectationOrigins
	results            *ChatServiceIMockDeleteChatResults
	returnOrigin       string
	Counter            uint64
}

// ChatServiceIMockDeleteChatParams contains parameters of the ChatServiceI.DeleteChat
type ChatServiceIMockDeleteChatParams struct {
	ctx context.Context
	id  int64
}

// ChatServiceIMockDeleteChatParamPtrs contains pointers to parameters of the ChatServiceI.DeleteChat
type ChatServiceIMockDeleteChatParamPtrs struct {
	ctx *context.Context
	id  *int64
}

// ChatServiceIMockDeleteChatResults contains results of the ChatServiceI.DeleteChat
type ChatServiceIMockDeleteChatResults struct {
	err error
}

// ChatServiceIMockDeleteChatOrigins contains origins of expectations of the ChatServiceI.DeleteChat
type ChatServiceIMockDeleteChatExpectationOrigins struct {
	origin    string
	originCtx string
	originId  string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmDeleteChat *mChatServiceIMockDeleteChat) Optional() *mChatServiceIMockDeleteChat {
	mmDeleteChat.optional = true
	return mmDeleteChat
}

// Expect sets up expected params for ChatServiceI.DeleteChat
func (mmDeleteChat *mChatServiceIMockDeleteChat) Expect(ctx context.Context, id int64) *mChatServiceIMockDeleteChat {
	if mmDeleteChat.mock.funcDeleteChat != nil {
		mmDeleteChat.mock.t.Fatalf("ChatServiceIMock.DeleteChat mock is already set by Set")
	}

	if mmDeleteChat.defaultExpectation == nil {
		mmDeleteChat.defaultExpectation = &ChatServiceIMockDeleteChatExpectation{}
	}

	if mmDeleteChat.defaultExpectation.paramPtrs != nil {
		mmDeleteChat.mock.t.Fatalf("ChatServiceIMock.DeleteChat mock is already set by ExpectParams functions")
	}

	mmDeleteChat.defaultExpectation.params = &ChatServiceIMockDeleteChatParams{ctx, id}
	mmDeleteChat.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmDeleteChat.expectations {
		if minimock.Equal(e.params, mmDeleteChat.defaultExpectation.params) {
			mmDeleteChat.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmDeleteChat.defaultExpectation.params)
		}
	}

	return mmDeleteChat
}

// ExpectCtxParam1 sets up expected param ctx for ChatServiceI.DeleteChat
func (mmDeleteChat *mChatServiceIMockDeleteChat) ExpectCtxParam1(ctx context.Context) *mChatServiceIMockDeleteChat {
	if mmDeleteChat.mock.funcDeleteChat != nil {
		mmDeleteChat.mock.t.Fatalf("ChatServiceIMock.DeleteChat mock is already set by Set")
	}

	if mmDeleteChat.defaultExpectation == nil {
		mmDeleteChat.defaultExpectation = &ChatServiceIMockDeleteChatExpectation{}
	}

	if mmDeleteChat.defaultExpectation.params != nil {
		mmDeleteChat.mock.t.Fatalf("ChatServiceIMock.DeleteChat mock is already set by Expect")
	}

	if mmDeleteChat.defaultExpectation.paramPtrs == nil {
		mmDeleteChat.defaultExpectation.paramPtrs = &ChatServiceIMockDeleteChatParamPtrs{}
	}
	mmDeleteChat.defaultExpectation.paramPtrs.ctx = &ctx
	mmDeleteChat.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmDeleteChat
}

// ExpectIdParam2 sets up expected param id for ChatServiceI.DeleteChat
func (mmDeleteChat *mChatServiceIMockDeleteChat) ExpectIdParam2(id int64) *mChatServiceIMockDeleteChat {
	if mmDeleteChat.mock.funcDeleteChat != nil {
		mmDeleteChat.mock.t.Fatalf("ChatServiceIMock.DeleteChat mock is already set by Set")
	}

	if mmDeleteChat.defaultExpectation == nil {
		mmDeleteChat.defaultExpectation = &ChatServiceIMockDeleteChatExpectation{}
	}

	if mmDeleteChat.defaultExpectation.params != nil {
		mmDeleteChat.mock.t.Fatalf("ChatServiceIMock.DeleteChat mock is already set by Expect")
	}

	if mmDeleteChat.defaultExpectation.paramPtrs == nil {
		mmDeleteChat.defaultExpectation.paramPtrs = &ChatServiceIMockDeleteChatParamPtrs{}
	}
	mmDeleteChat.defaultExpectation.paramPtrs.id = &id
	mmDeleteChat.defaultExpectation.expectationOrigins.originId = minimock.CallerInfo(1)

	return mmDeleteChat
}

// Inspect accepts an inspector function that has same arguments as the ChatServiceI.DeleteChat
func (mmDeleteChat *mChatServiceIMockDeleteChat) Inspect(f func(ctx context.Context, id int64)) *mChatServiceIMockDeleteChat {
	if mmDeleteChat.mock.inspectFuncDeleteChat != nil {
		mmDeleteChat.mock.t.Fatalf("Inspect function is already set for ChatServiceIMock.DeleteChat")
	}

	mmDeleteChat.mock.inspectFuncDeleteChat = f

	return mmDeleteChat
}

// Return sets up results that will be returned by ChatServiceI.DeleteChat
func (mmDeleteChat *mChatServiceIMockDeleteChat) Return(err error) *ChatServiceIMock {
	if mmDeleteChat.mock.funcDeleteChat != nil {
		mmDeleteChat.mock.t.Fatalf("ChatServiceIMock.DeleteChat mock is already set by Set")
	}

	if mmDeleteChat.defaultExpectation == nil {
		mmDeleteChat.defaultExpectation = &ChatServiceIMockDeleteChatExpectation{mock: mmDeleteChat.mock}
	}
	mmDeleteChat.defaultExpectation.results = &ChatServiceIMockDeleteChatResults{err}
	mmDeleteChat.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmDeleteChat.mock
}

// Set uses given function f to mock the ChatServiceI.DeleteChat method
func (mmDeleteChat *mChatServiceIMockDeleteChat) Set(f func(ctx context.Context, id int64) (err error)) *ChatServiceIMock {
	if mmDeleteChat.defaultExpectation != nil {
		mmDeleteChat.mock.t.Fatalf("Default expectation is already set for the ChatServiceI.DeleteChat method")
	}

	if len(mmDeleteChat.expectations) > 0 {
		mmDeleteChat.mock.t.Fatalf("Some expectations are already set for the ChatServiceI.DeleteChat method")
	}

	mmDeleteChat.mock.funcDeleteChat = f
	mmDeleteChat.mock.funcDeleteChatOrigin = minimock.CallerInfo(1)
	return mmDeleteChat.mock
}

// When sets expectation for the ChatServiceI.DeleteChat which will trigger the result defined by the following
// Then helper
func (mmDeleteChat *mChatServiceIMockDeleteChat) When(ctx context.Context, id int64) *ChatServiceIMockDeleteChatExpectation {
	if mmDeleteChat.mock.funcDeleteChat != nil {
		mmDeleteChat.mock.t.Fatalf("ChatServiceIMock.DeleteChat mock is already set by Set")
	}

	expectation := &ChatServiceIMockDeleteChatExpectation{
		mock:               mmDeleteChat.mock,
		params:             &ChatServiceIMockDeleteChatParams{ctx, id},
		expectationOrigins: ChatServiceIMockDeleteChatExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmDeleteChat.expectations = append(mmDeleteChat.expectations, expectation)
	return expectation
}

// Then sets up ChatServiceI.DeleteChat return parameters for the expectation previously defined by the When method
func (e *ChatServiceIMockDeleteChatExpectation) Then(err error) *ChatServiceIMock {
	e.results = &ChatServiceIMockDeleteChatResults{err}
	return e.mock
}

// Times sets number of times ChatServiceI.DeleteChat should be invoked
func (mmDeleteChat *mChatServiceIMockDeleteChat) Times(n uint64) *mChatServiceIMockDeleteChat {
	if n == 0 {
		mmDeleteChat.mock.t.Fatalf("Times of ChatServiceIMock.DeleteChat mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmDeleteChat.expectedInvocations, n)
	mmDeleteChat.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmDeleteChat
}

func (mmDeleteChat *mChatServiceIMockDeleteChat) invocationsDone() bool {
	if len(mmDeleteChat.expectations) == 0 && mmDeleteChat.defaultExpectation == nil && mmDeleteChat.mock.funcDeleteChat == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmDeleteChat.mock.afterDeleteChatCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmDeleteChat.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// DeleteChat implements mm_service.ChatServiceI
func (mmDeleteChat *ChatServiceIMock) DeleteChat(ctx context.Context, id int64) (err error) {
	mm_atomic.AddUint64(&mmDeleteChat.beforeDeleteChatCounter, 1)
	defer mm_atomic.AddUint64(&mmDeleteChat.afterDeleteChatCounter, 1)

	mmDeleteChat.t.Helper()

	if mmDeleteChat.inspectFuncDeleteChat != nil {
		mmDeleteChat.inspectFuncDeleteChat(ctx, id)
	}

	mm_params := ChatServiceIMockDeleteChatParams{ctx, id}

	// Record call args
	mmDeleteChat.DeleteChatMock.mutex.Lock()
	mmDeleteChat.DeleteChatMock.callArgs = append(mmDeleteChat.DeleteChatMock.callArgs, &mm_params)
	mmDeleteChat.DeleteChatMock.mutex.Unlock()

	for _, e := range mmDeleteChat.DeleteChatMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmDeleteChat.DeleteChatMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmDeleteChat.DeleteChatMock.defaultExpectation.Counter, 1)
		mm_want := mmDeleteChat.DeleteChatMock.defaultExpectation.params
		mm_want_ptrs := mmDeleteChat.DeleteChatMock.defaultExpectation.paramPtrs

		mm_got := ChatServiceIMockDeleteChatParams{ctx, id}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmDeleteChat.t.Errorf("ChatServiceIMock.DeleteChat got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmDeleteChat.DeleteChatMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.id != nil && !minimock.Equal(*mm_want_ptrs.id, mm_got.id) {
				mmDeleteChat.t.Errorf("ChatServiceIMock.DeleteChat got unexpected parameter id, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmDeleteChat.DeleteChatMock.defaultExpectation.expectationOrigins.originId, *mm_want_ptrs.id, mm_got.id, minimock.Diff(*mm_want_ptrs.id, mm_got.id))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmDeleteChat.t.Errorf("ChatServiceIMock.DeleteChat got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmDeleteChat.DeleteChatMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmDeleteChat.DeleteChatMock.defaultExpectation.results
		if mm_results == nil {
			mmDeleteChat.t.Fatal("No results are set for the ChatServiceIMock.DeleteChat")
		}
		return (*mm_results).err
	}
	if mmDeleteChat.funcDeleteChat != nil {
		return mmDeleteChat.funcDeleteChat(ctx, id)
	}
	mmDeleteChat.t.Fatalf("Unexpected call to ChatServiceIMock.DeleteChat. %v %v", ctx, id)
	return
}

// DeleteChatAfterCounter returns a count of finished ChatServiceIMock.DeleteChat invocations
func (mmDeleteChat *ChatServiceIMock) DeleteChatAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmDeleteChat.afterDeleteChatCounter)
}

// DeleteChatBeforeCounter returns a count of ChatServiceIMock.DeleteChat invocations
func (mmDeleteChat *ChatServiceIMock) DeleteChatBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmDeleteChat.beforeDeleteChatCounter)
}

// Calls returns a list of arguments used in each call to ChatServiceIMock.DeleteChat.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmDeleteChat *mChatServiceIMockDeleteChat) Calls() []*ChatServiceIMockDeleteChatParams {
	mmDeleteChat.mutex.RLock()

	argCopy := make([]*ChatServiceIMockDeleteChatParams, len(mmDeleteChat.callArgs))
	copy(argCopy, mmDeleteChat.callArgs)

	mmDeleteChat.mutex.RUnlock()

	return argCopy
}

// MinimockDeleteChatDone returns true if the count of the DeleteChat invocations corresponds
// the number of defined expectations
func (m *ChatServiceIMock) MinimockDeleteChatDone() bool {
	if m.DeleteChatMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.DeleteChatMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.DeleteChatMock.invocationsDone()
}

// MinimockDeleteChatInspect logs each unmet expectation
func (m *ChatServiceIMock) MinimockDeleteChatInspect() {
	for _, e := range m.DeleteChatMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to ChatServiceIMock.DeleteChat at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterDeleteChatCounter := mm_atomic.LoadUint64(&m.afterDeleteChatCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.DeleteChatMock.defaultExpectation != nil && afterDeleteChatCounter < 1 {
		if m.DeleteChatMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to ChatServiceIMock.DeleteChat at\n%s", m.DeleteChatMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to ChatServiceIMock.DeleteChat at\n%s with params: %#v", m.DeleteChatMock.defaultExpectation.expectationOrigins.origin, *m.DeleteChatMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcDeleteChat != nil && afterDeleteChatCounter < 1 {
		m.t.Errorf("Expected call to ChatServiceIMock.DeleteChat at\n%s", m.funcDeleteChatOrigin)
	}

	if !m.DeleteChatMock.invocationsDone() && afterDeleteChatCounter > 0 {
		m.t.Errorf("Expected %d calls to ChatServiceIMock.DeleteChat at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.DeleteChatMock.expectedInvocations), m.DeleteChatMock.expectedInvocationsOrigin, afterDeleteChatCounter)
	}
}

type mChatServiceIMockDeleteUser struct {
	optional           bool
	mock               *ChatServiceIMock
	defaultExpectation *ChatServiceIMockDeleteUserExpectation
	expectations       []*ChatServiceIMockDeleteUserExpectation

	callArgs []*ChatServiceIMockDeleteUserParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// ChatServiceIMockDeleteUserExpectation specifies expectation struct of the ChatServiceI.DeleteUser
type ChatServiceIMockDeleteUserExpectation struct {
	mock               *ChatServiceIMock
	params             *ChatServiceIMockDeleteUserParams
	paramPtrs          *ChatServiceIMockDeleteUserParamPtrs
	expectationOrigins ChatServiceIMockDeleteUserExpectationOrigins
	results            *ChatServiceIMockDeleteUserResults
	returnOrigin       string
	Counter            uint64
}

// ChatServiceIMockDeleteUserParams contains parameters of the ChatServiceI.DeleteUser
type ChatServiceIMockDeleteUserParams struct {
	ctx context.Context
	id  int64
}

// ChatServiceIMockDeleteUserParamPtrs contains pointers to parameters of the ChatServiceI.DeleteUser
type ChatServiceIMockDeleteUserParamPtrs struct {
	ctx *context.Context
	id  *int64
}

// ChatServiceIMockDeleteUserResults contains results of the ChatServiceI.DeleteUser
type ChatServiceIMockDeleteUserResults struct {
	err error
}

// ChatServiceIMockDeleteUserOrigins contains origins of expectations of the ChatServiceI.DeleteUser
type ChatServiceIMockDeleteUserExpectationOrigins struct {
	origin    string
	originCtx string
	originId  string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmDeleteUser *mChatServiceIMockDeleteUser) Optional() *mChatServiceIMockDeleteUser {
	mmDeleteUser.optional = true
	return mmDeleteUser
}

// Expect sets up expected params for ChatServiceI.DeleteUser
func (mmDeleteUser *mChatServiceIMockDeleteUser) Expect(ctx context.Context, id int64) *mChatServiceIMockDeleteUser {
	if mmDeleteUser.mock.funcDeleteUser != nil {
		mmDeleteUser.mock.t.Fatalf("ChatServiceIMock.DeleteUser mock is already set by Set")
	}

	if mmDeleteUser.defaultExpectation == nil {
		mmDeleteUser.defaultExpectation = &ChatServiceIMockDeleteUserExpectation{}
	}

	if mmDeleteUser.defaultExpectation.paramPtrs != nil {
		mmDeleteUser.mock.t.Fatalf("ChatServiceIMock.DeleteUser mock is already set by ExpectParams functions")
	}

	mmDeleteUser.defaultExpectation.params = &ChatServiceIMockDeleteUserParams{ctx, id}
	mmDeleteUser.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmDeleteUser.expectations {
		if minimock.Equal(e.params, mmDeleteUser.defaultExpectation.params) {
			mmDeleteUser.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmDeleteUser.defaultExpectation.params)
		}
	}

	return mmDeleteUser
}

// ExpectCtxParam1 sets up expected param ctx for ChatServiceI.DeleteUser
func (mmDeleteUser *mChatServiceIMockDeleteUser) ExpectCtxParam1(ctx context.Context) *mChatServiceIMockDeleteUser {
	if mmDeleteUser.mock.funcDeleteUser != nil {
		mmDeleteUser.mock.t.Fatalf("ChatServiceIMock.DeleteUser mock is already set by Set")
	}

	if mmDeleteUser.defaultExpectation == nil {
		mmDeleteUser.defaultExpectation = &ChatServiceIMockDeleteUserExpectation{}
	}

	if mmDeleteUser.defaultExpectation.params != nil {
		mmDeleteUser.mock.t.Fatalf("ChatServiceIMock.DeleteUser mock is already set by Expect")
	}

	if mmDeleteUser.defaultExpectation.paramPtrs == nil {
		mmDeleteUser.defaultExpectation.paramPtrs = &ChatServiceIMockDeleteUserParamPtrs{}
	}
	mmDeleteUser.defaultExpectation.paramPtrs.ctx = &ctx
	mmDeleteUser.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmDeleteUser
}

// ExpectIdParam2 sets up expected param id for ChatServiceI.DeleteUser
func (mmDeleteUser *mChatServiceIMockDeleteUser) ExpectIdParam2(id int64) *mChatServiceIMockDeleteUser {
	if mmDeleteUser.mock.funcDeleteUser != nil {
		mmDeleteUser.mock.t.Fatalf("ChatServiceIMock.DeleteUser mock is already set by Set")
	}

	if mmDeleteUser.defaultExpectation == nil {
		mmDeleteUser.defaultExpectation = &ChatServiceIMockDeleteUserExpectation{}
	}

	if mmDeleteUser.defaultExpectation.params != nil {
		mmDeleteUser.mock.t.Fatalf("ChatServiceIMock.DeleteUser mock is already set by Expect")
	}

	if mmDeleteUser.defaultExpectation.paramPtrs == nil {
		mmDeleteUser.defaultExpectation.paramPtrs = &ChatServiceIMockDeleteUserParamPtrs{}
	}
	mmDeleteUser.defaultExpectation.paramPtrs.id = &id
	mmDeleteUser.defaultExpectation.expectationOrigins.originId = minimock.CallerInfo(1)

	return mmDeleteUser
}

// Inspect accepts an inspector function that has same arguments as the ChatServiceI.DeleteUser
func (mmDeleteUser *mChatServiceIMockDeleteUser) Inspect(f func(ctx context.Context, id int64)) *mChatServiceIMockDeleteUser {
	if mmDeleteUser.mock.inspectFuncDeleteUser != nil {
		mmDeleteUser.mock.t.Fatalf("Inspect function is already set for ChatServiceIMock.DeleteUser")
	}

	mmDeleteUser.mock.inspectFuncDeleteUser = f

	return mmDeleteUser
}

// Return sets up results that will be returned by ChatServiceI.DeleteUser
func (mmDeleteUser *mChatServiceIMockDeleteUser) Return(err error) *ChatServiceIMock {
	if mmDeleteUser.mock.funcDeleteUser != nil {
		mmDeleteUser.mock.t.Fatalf("ChatServiceIMock.DeleteUser mock is already set by Set")
	}

	if mmDeleteUser.defaultExpectation == nil {
		mmDeleteUser.defaultExpectation = &ChatServiceIMockDeleteUserExpectation{mock: mmDeleteUser.mock}
	}
	mmDeleteUser.defaultExpectation.results = &ChatServiceIMockDeleteUserResults{err}
	mmDeleteUser.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmDeleteUser.mock
}

// Set uses given function f to mock the ChatServiceI.DeleteUser method
func (mmDeleteUser *mChatServiceIMockDeleteUser) Set(f func(ctx context.Context, id int64) (err error)) *ChatServiceIMock {
	if mmDeleteUser.defaultExpectation != nil {
		mmDeleteUser.mock.t.Fatalf("Default expectation is already set for the ChatServiceI.DeleteUser method")
	}

	if len(mmDeleteUser.expectations) > 0 {
		mmDeleteUser.mock.t.Fatalf("Some expectations are already set for the ChatServiceI.DeleteUser method")
	}

	mmDeleteUser.mock.funcDeleteUser = f
	mmDeleteUser.mock.funcDeleteUserOrigin = minimock.CallerInfo(1)
	return mmDeleteUser.mock
}

// When sets expectation for the ChatServiceI.DeleteUser which will trigger the result defined by the following
// Then helper
func (mmDeleteUser *mChatServiceIMockDeleteUser) When(ctx context.Context, id int64) *ChatServiceIMockDeleteUserExpectation {
	if mmDeleteUser.mock.funcDeleteUser != nil {
		mmDeleteUser.mock.t.Fatalf("ChatServiceIMock.DeleteUser mock is already set by Set")
	}

	expectation := &ChatServiceIMockDeleteUserExpectation{
		mock:               mmDeleteUser.mock,
		params:             &ChatServiceIMockDeleteUserParams{ctx, id},
		expectationOrigins: ChatServiceIMockDeleteUserExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmDeleteUser.expectations = append(mmDeleteUser.expectations, expectation)
	return expectation
}

// Then sets up ChatServiceI.DeleteUser return parameters for the expectation previously defined by the When method
func (e *ChatServiceIMockDeleteUserExpectation) Then(err error) *ChatServiceIMock {
	e.results = &ChatServiceIMockDeleteUserResults{err}
	return e.mock
}

// Times sets number of times ChatServiceI.DeleteUser should be invoked
func (mmDeleteUser *mChatServiceIMockDeleteUser) Times(n uint64) *mChatServiceIMockDeleteUser {
	if n == 0 {
		mmDeleteUser.mock.t.Fatalf("Times of ChatServiceIMock.DeleteUser mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmDeleteUser.expectedInvocations, n)
	mmDeleteUser.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmDeleteUser
}

func (mmDeleteUser *mChatServiceIMockDeleteUser) invocationsDone() bool {
	if len(mmDeleteUser.expectations) == 0 && mmDeleteUser.defaultExpectation == nil && mmDeleteUser.mock.funcDeleteUser == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmDeleteUser.mock.afterDeleteUserCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmDeleteUser.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// DeleteUser implements mm_service.ChatServiceI
func (mmDeleteUser *ChatServiceIMock) DeleteUser(ctx context.Context, id int64) (err error) {
	mm_atomic.AddUint64(&mmDeleteUser.beforeDeleteUserCounter, 1)
	defer mm_atomic.AddUint64(&mmDeleteUser.afterDeleteUserCounter, 1)

	mmDeleteUser.t.Helper()

	if mmDeleteUser.inspectFuncDeleteUser != nil {
		mmDeleteUser.inspectFuncDeleteUser(ctx, id)
	}

	mm_params := ChatServiceIMockDeleteUserParams{ctx, id}

	// Record call args
	mmDeleteUser.DeleteUserMock.mutex.Lock()
	mmDeleteUser.DeleteUserMock.callArgs = append(mmDeleteUser.DeleteUserMock.callArgs, &mm_params)
	mmDeleteUser.DeleteUserMock.mutex.Unlock()

	for _, e := range mmDeleteUser.DeleteUserMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmDeleteUser.DeleteUserMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmDeleteUser.DeleteUserMock.defaultExpectation.Counter, 1)
		mm_want := mmDeleteUser.DeleteUserMock.defaultExpectation.params
		mm_want_ptrs := mmDeleteUser.DeleteUserMock.defaultExpectation.paramPtrs

		mm_got := ChatServiceIMockDeleteUserParams{ctx, id}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmDeleteUser.t.Errorf("ChatServiceIMock.DeleteUser got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmDeleteUser.DeleteUserMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.id != nil && !minimock.Equal(*mm_want_ptrs.id, mm_got.id) {
				mmDeleteUser.t.Errorf("ChatServiceIMock.DeleteUser got unexpected parameter id, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmDeleteUser.DeleteUserMock.defaultExpectation.expectationOrigins.originId, *mm_want_ptrs.id, mm_got.id, minimock.Diff(*mm_want_ptrs.id, mm_got.id))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmDeleteUser.t.Errorf("ChatServiceIMock.DeleteUser got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmDeleteUser.DeleteUserMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmDeleteUser.DeleteUserMock.defaultExpectation.results
		if mm_results == nil {
			mmDeleteUser.t.Fatal("No results are set for the ChatServiceIMock.DeleteUser")
		}
		return (*mm_results).err
	}
	if mmDeleteUser.funcDeleteUser != nil {
		return mmDeleteUser.funcDeleteUser(ctx, id)
	}
	mmDeleteUser.t.Fatalf("Unexpected call to ChatServiceIMock.DeleteUser. %v %v", ctx, id)
	return
}

// DeleteUserAfterCounter returns a count of finished ChatServiceIMock.DeleteUser invocations
func (mmDeleteUser *ChatServiceIMock) DeleteUserAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmDeleteUser.afterDeleteUserCounter)
}

// DeleteUserBeforeCounter returns a count of ChatServiceIMock.DeleteUser invocations
func (mmDeleteUser *ChatServiceIMock) DeleteUserBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmDeleteUser.beforeDeleteUserCounter)
}

// Calls returns a list of arguments used in each call to ChatServiceIMock.DeleteUser.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmDeleteUser *mChatServiceIMockDeleteUser) Calls() []*ChatServiceIMockDeleteUserParams {
	mmDeleteUser.mutex.RLock()

	argCopy := make([]*ChatServiceIMockDeleteUserParams, len(mmDeleteUser.callArgs))
	copy(argCopy, mmDeleteUser.callArgs)

	mmDeleteUser.mutex.RUnlock()

	return argCopy
}

// MinimockDeleteUserDone returns true if the count of the DeleteUser invocations corresponds
// the number of defined expectations
func (m *ChatServiceIMock) MinimockDeleteUserDone() bool {
	if m.DeleteUserMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.DeleteUserMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.DeleteUserMock.invocationsDone()
}

// MinimockDeleteUserInspect logs each unmet expectation
func (m *ChatServiceIMock) MinimockDeleteUserInspect() {
	for _, e := range m.DeleteUserMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to ChatServiceIMock.DeleteUser at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterDeleteUserCounter := mm_atomic.LoadUint64(&m.afterDeleteUserCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.DeleteUserMock.defaultExpectation != nil && afterDeleteUserCounter < 1 {
		if m.DeleteUserMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to ChatServiceIMock.DeleteUser at\n%s", m.DeleteUserMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to ChatServiceIMock.DeleteUser at\n%s with params: %#v", m.DeleteUserMock.defaultExpectation.expectationOrigins.origin, *m.DeleteUserMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcDeleteUser != nil && afterDeleteUserCounter < 1 {
		m.t.Errorf("Expected call to ChatServiceIMock.DeleteUser at\n%s", m.funcDeleteUserOrigin)
	}

	if !m.DeleteUserMock.invocationsDone() && afterDeleteUserCounter > 0 {
		m.t.Errorf("Expected %d calls to ChatServiceIMock.DeleteUser at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.DeleteUserMock.expectedInvocations), m.DeleteUserMock.expectedInvocationsOrigin, afterDeleteUserCounter)
	}
}

// MinimockFinish checks that all mocked methods have been called the expected number of times
func (m *ChatServiceIMock) MinimockFinish() {
	m.finishOnce.Do(func() {
		if !m.minimockDone() {
			m.MinimockCreateChatInspect()

			m.MinimockCreateMessageInspect()

			m.MinimockCreateUserInspect()

			m.MinimockDeleteChatInspect()

			m.MinimockDeleteUserInspect()
		}
	})
}

// MinimockWait waits for all mocked methods to be called the expected number of times
func (m *ChatServiceIMock) MinimockWait(timeout mm_time.Duration) {
	timeoutCh := mm_time.After(timeout)
	for {
		if m.minimockDone() {
			return
		}
		select {
		case <-timeoutCh:
			m.MinimockFinish()
			return
		case <-mm_time.After(10 * mm_time.Millisecond):
		}
	}
}

func (m *ChatServiceIMock) minimockDone() bool {
	done := true
	return done &&
		m.MinimockCreateChatDone() &&
		m.MinimockCreateMessageDone() &&
		m.MinimockCreateUserDone() &&
		m.MinimockDeleteChatDone() &&
		m.MinimockDeleteUserDone()
}
